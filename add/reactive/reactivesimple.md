# Реактивний в двох словах

https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch01.html

Почнемо з початку. Забудьте про програмне забезпечення та ІТ на кілька хвилин і скористайтеся старомодним підходом. Якщо ми шукаємо реактивний в Оксфордському словнику англійської мови, ми знаходимо таке визначення:

 реактивний (прикметник)

Показ реакції на подразник. 1.1 Діяти у відповідь на ситуацію, а не створювати або контролювати її. 1.2 Схильність до хімічної реакції. 1.3 (Фізіологія) Виявлення імунної відповіді на специфічний антиген. 1.4 (Про хворобу або хворобу) Викликаний реакцією на щось. 1.5 (Фізика) Що стосується реактивного опору.

Серед цих визначень два доречні в нашому контексті. Перше визначення, що показує реакцію на подразник, відноситься до якогось виду реакції. Бути реактивним означає реагувати на подразники, якими б вони не були. Підвизначення 1.1 говорить, що бути реактивним також означає зіткнутися з несподіваними та неконтрольованими ситуаціями. У цій книзі ви побачите, що власні хмарні програми та розподілені системи загалом стикаються з багатьма такими ситуаціями. Хоча ці визначення цікаві, вони не стосуються програмного забезпечення. Але ми можемо взяти до уваги ці визначення, щоб створити нове, специфічне для програмного забезпечення:

1.6 (Програмне забезпечення) Програма, що реагує на подразники, такі як події користувача, запити та збої.

Проте, як ви побачите в цій книзі, сьогоднішня реактивність виходить за рамки цього. Реактивний — це підхід до проектування, реалізації та міркування про вашу систему з точки зору подій і потоків. Reactive — це створення чутливих, стійких і еластичних додатків. Reactive також стосується використання ресурсів шляхом ефективного управління ресурсами та комунікації. Іншими словами: Reactive — це проектування та створення кращих розподілених систем — більш надійних і ефективніших. Ми називаємо їх реактивними системами.

## Реактивне програмне забезпечення не нове

Але зачекайте, визначення (1.6), яке ми щойно дали, не є новаторським. Навпаки, ви можете відчути деяке дежавю, чи не так? Хіба природа програмного забезпечення не реагує на введення користувача та сигнали операційної системи? Як програмне забезпечення поводиться, коли ви натискаєте клавішу? Воно реагує. Отже, чому так багато книг, розмов і дебатів про Reactive, якщо це звичайне програмне забезпечення?1 Будьте терплячі; це трохи більше.

Але ви маєте рацію; Реактив не новий. Насправді він досить старий. Ми можемо прослідкувати основу ідей реактивного програмного забезпечення відразу після появи комп’ютерів у 50-х роках. DYSEAC, комп’ютер першого покоління (працював у 1954 році), вже використовував апаратні переривання як оптимізацію, усуваючи час очікування в циклах опитування. Цей комп’ютер був однією з перших систем, яка використовує реактивну та керовану подіями архітектуру!

Реагування на події передбачає керованість подіями. Програмне забезпечення, кероване подіями, отримує та створює події. Отримані події визначають хід програми. Фундаментальним аспектом керованості подіями є асинхронність: ви не знаєте, коли отримаєте події (Асинхронний – протилежність синхронному. Бути асинхронним означає відбуватися в різний момент часу, тоді як бути синхронним означає відбуватися одночасно). Це якраз визначення 1.1 з попереднього розділу. Ви не можете спланувати, коли ви отримаєте події, не можете контролювати, які події ви отримаєте, і ви повинні бути готові впоратися з ними. Це суть реактивності: бути асинхронним.

## Реактивний ландшафт

З цієї ідеї бути асинхронним і керованим подіями виникло багато форм *Reactive*. Реактивний ландшафт широкий і багатолюдний. [Малюнок 1-1](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch01.html#image:landscape) зображує уривок цього пейзажу та зв’язки між основними *реактивні речі*.

![The reactive landscape](https://www.oreilly.com/api/v2/epubs/9781492091714/files/assets/rsij_0101.png)

Figure 1-1. The reactive landscape

Але не забувайте про нашу мету: створення краще розподілених систем — реактивних систем. Інші «реактивні» тут, щоб допомогти нам впровадити ці системи.

Причини Reactive і реактивних систем зокрема походять від розподілених систем. Як ви побачите в [розділі 3](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch03.html#distributed-system), побудова розподілених систем є важкою справою. У 2013 році експерти з розподілених систем написали першу версію [“The Reactive Manifesto”](https://oreil.ly/6z8mt) і представили концепцію реактивних систем.

Так, ви можете створювати розподілені системи без застосування реактивних принципів. Reactive надає схему, яка гарантує, що під час архітектури та розробки вашої системи не було пропущено жодних значних відомих проблем. З іншого боку, ви можете застосувати ці принципи до нерозподілених систем.

Реактивна система перш за все чуйна. Він повинен своєчасно обробляти запити навіть під навантаженням або при збоях. Щоб досягти такої оперативності, маніфест пропонує використовувати асинхронну передачу повідомлень як основний спосіб зв’язку між компонентами, що утворюють систему. У [Chapter 4](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch04.html#reactive-systems) ви побачите, як цей метод зв’язку забезпечує еластичність і стійкість, два важливі атрибути твердих розподілених систем. Мета цієї книги — показати вам, як створювати такі реактивні системи за допомогою Quarkus. Отже, побудова реактивних систем є нашою основною метою.

Впровадження асинхронної передачі повідомлень у ядро розподілених систем не обходиться без наслідків. Ваша програма має використовувати асинхронний код і неблокуючий ввід-вивід, здатність, надану операційною системою, ставити в чергу взаємодії вводу-виводу без необхідності активно чекати завершення. (Ми розглядаємо неблокуючі вводи-виводи в[Chapter 4](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch04.html#reactive-systems)). Останнє має важливе значення для покращення використання ресурсів, таких як процесор і пам’ять, ще один важливий аспект Reactive. Сьогодні багато наборів інструментів і фреймворків, таких як Quarkus, [Eclipse Vert.x](https://vertx.io), [Micronaut](https://micronaut.io), [Helidon](https://helidon. io) і [Netty](https://netty.io), використовують неблокуючий ввід-вивід саме з цієї причини: робити більше з обмеженими ресурсами.

І все ж наявності середовища виконання, що використовує неблокуючий ввід-вивід, недостатньо для реагування. Вам також потрібно написати асинхронний код, що включає неблокуючу механіку введення-виведення. В іншому випадку вигоди від використання ресурсів зникнуть. Написання асинхронного коду є зміною парадигми. Від традиційного (наказового способу) `do x; do y;`, тепер ви збираєтеся сформувати свій код як `on event(e) do x; у події (f) виконайте y;`. Іншими словами, щоб бути реактивним, ваша система має не тільки керовану подіями архітектуру, але й ваш код стане керованою подіями. Одним із найпростіших підходів до реалізації такого коду є зворотні виклики: ви реєструєте функції, що викликаються, коли надходять події. Як і ф’ючерси, обіцянки та співпрограми, будь-який інший підхід базується на зворотних викликах і пропонує API вищого рівня.

Ви можете запитати, чому електронні таблиці розташовані в ландшафті. Електронні таблиці реактивні. Коли ви записуєте формулу в клітинку та змінюєте значення, прочитане (в іншій клітинці) формулою, результат цієї формули оновлюється. Комірка реагує на оновлення значення (події), а результатом (реакцією) є новий результат. Так, ваш менеджер може бути кращим реактивним розробником, ніж ви! Але не хвилюйтеся, ця книга змінить це.

Реактивне програмування, розглянуте в  [Chapter 5](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch05.html#reactive-programming), також є підходом до написання асинхронного коду. Він використовує потоки даних для структурування вашого коду. Ви спостерігаєте за даними, що передаються в цих потоках, і реагуєте на це. Реактивне програмування забезпечує потужну абстракцію та API для формування керованого подіями коду.

Але використання потоків даних пов’язане з проблемою. Якщо у вас є швидкий виробник, безпосередньо підключений до повільного споживача, ви можете затопити споживача. Як ви побачите, ми можемо буферизувати або використовувати брокер повідомлень між ними, але уявіть, що ми заповнюємо споживача без нього. Це суперечило б ідеям реагування та антикрихкості, які просуває Reactive. Щоб допомогти нам із цією конкретною проблемою, [Reactive Streams](https://oreil.ly/5c275) пропонує асинхронний і неблокуючий протокол зворотного тиску, за допомогою якого споживач сигналізує виробнику про наявність. Як ви можете собі уявити, це може бути застосовано не скрізь, оскільки деякі джерела даних не можуть сповільнюватися.

Популярність Reactive Streams зросла за останні кілька років. Наприклад, [RSocket](https://rsocket.io) — це мережевий протокол на основі реактивних потоків. [R2DBC](https://r2dbc.io) пропонує асинхронний доступ до бази даних за допомогою Reactive Streams. Крім того, прийнято [RxJava](https://oreil.ly/QNEOJ), [Project Reactor](https://oreil.ly/eUHAL) і [SmallRye Mutiny](https://oreil.ly/A17fF) реактивні потоки для боротьби з протитиском. Нарешті, Vert.x дозволяє зіставляти модель зворотного тиску Vert.x з реактивними потоками.[3](https://www.oreilly.com/library/view/reactive-systems-in/9781492091714/ch01.html#idm45358839696288)

