[Зміст](README.md)

# 8. Серіалізація з використанням XML та JSON

## 8.1. Серіалізація

Обмін даними в комп’ютерних системах зазвичай відбувається з використанням структурованих даних. Ці дані зберігаються, обробляються і передаються між пристроями та системами. Найпростішим способом могло б бути просте копіювання та передача області пам'яті в бінарному форматі. Однак комп’ютерні системи можуть мати різні апаратні архітектури та різні способи представлення даних, зокрема:

- дані атомарних типів можуть бути представлені в оперативній пам’яті по-різному
- виділення пам'яті для структурних даних може відбуватися різним чином а отже по різному інтерпретуватися. 

Обмін даними в двійковому вигляді між системами з різною організацією пам’яті, у разі використання атомарних типів і при неінтепретованій їх обробці, з великою вірогідністю призведе до помилок. Так на рис.8.1 показано, що одне і те саме число може по різному інтерпретуватися, так як одні системи сприймають перший байт як старший, а інші як молодший.

![image-20221225204802255](xmljson/image-20221225204802255.png)

рис.8.1. Представлення даних в різних архітектурах комп'ютера. 

В обчислювальній техніці для цього використовується серіалізація/десерілазація.  **Серіалізація** (serialization, serialisation) або маршалинг - процес переведення структури даних або стану об’єкта у формат, який можна зберігати (файли, буфери) або передавати через мережу з послідуючим відновленням. Протилежною операцією, що витягує структуру даних із серії байтів, є **десеріалізація** (також називається демаршалинг).

Приклади застосування серіалізації включають такі методи, як:

- серіалізація даних для передачі в мережах (обмін повідомленнями)
- зберігання даних (у базах даних, на жорстких дисках)
- віддалені виклики процедур, наприклад, як у SOAP
- розповсюдження об’єктів, особливо в розробці програмного забезпечення на основі компонентів, наприклад COM, CORBA тощо.
- виявлення змін у даних що змінюються в часі

Як варіант організації формату передачі даних є представлення їх у вигляді тексту. Це звісно приведе до збільшення обсягу необхідної пам'яті та кількості даних що передаються а також збільшить затрати на їх обробку, але спростить задачу забезпечення сумісності. Додатковою перевагою текстового представлення є можливість передавати (і зберігати) не тільки самі дані, але і їх опис (метадані). Тому існуючі та використовувані текстові представлення (серіалізації) даних радше називається не форматом даних а мовою опису даних. 

При цьому варто також зауважити, що і при обміні текстовим представлення даних відправник та отримувач повинні однаково сприймати дані, якими обмінюються, інакше система не буде функціонувати належним чином. Тому дані перед обробкою бажано перевірити на відповідність певній схемі (**валідність**), що буде свідчити про їх правильну організацію. Така перевірка можлива лише за наявності додаткової інформації, яка б описувала таку схему. Наявність механізмів такої перевірки може стати важливим аргументом при виборі того чи іншого способу серіалізації.    

У цій лекції розглядається мова опису даних - XML, а в наступній - JSON, які на сьогодні найчастіше використовуються при обміні даними між комп'ютерними системами. Варто зазначити що є і інші мови серіалізації, наприклад YAML. Усі вони зберігають дані у форматі звичайного тексту. Це забезпечує незалежний від програмного та апаратного забезпечення спосіб зберігання, транспортування та спільного використання даних. За допомогою XML та JSON дані можуть бути доступні для всіх видів «машин для читання», таких як люди, комп’ютери, голосові машини, канали новин тощо.

## 8.2. Загальне представлення XML

### Загальне представлення

**XML** – eXtensible Markup Language – метамова, що надає гнучкий інструментарій формування документів, призначених для опису структур даних для їх машинної обробки. XML є еволюцією іншої мови SGML (Standard Generalised Markup Language) від якої також з'явилася мова HTML. XML використовується на практиці для опису складних структур даних (опис переліків полів даних, типів даних, способів їх обробки), обміну цими описами між комп’ютерними системами та збереження цих даних. Приклад XML:

```xml
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>
```

Наведений вище XML є досить описовим. Він містить інформацію про відправника, приймача, має заголовок, має тіло повідомлення. Але все одно наведений вище XML нічого не РОБИТЬ. XML — це просто інформація, загорнута в теги. Хтось повинен написати частину програмного забезпечення, щоб надсилати, отримувати, зберігати або відображати його.

HTML-документи також мають подібну структуру, але на відміну від мови HTML, XML-мова не має заздалегідь означеного набору тегів і фокусується на представленні даних а не відображення даних на сторінці. 

### Структура документу

Для початку перелічимо основні поняття і складові:

- **Теги** (Tag) – будь-яке слово латиницею, наприклад `<Tag>`, що вказує на розмітку даних, тобто загорнутий в `<` та `>`.
- **Зміст тегів (контент)** - все що знаходиться між між відкритими  `<Tag>` та закритими  `</Tag>` тегами 
- **Атрибути тегів**  - частини, які описують властивості (атрибути) об’єкта, у форматі `<Tag attribute=“attribute value”/>`
- Розділ даних DTD (CDATA) - блок даних, що не містить елементів розмітки (тільки корисне навантаження), наприклад, `<![CDATA[ *будь-які дані* ]]>` 
- Розділ коментарів, наприклад  `<!-- Commentaries -->`
- Метадані в заголовку - дані про документ, наприклад `<?xml version="1.0" encoding="UTF-8”?>`

**XML елемент** – одиниця опису XML, який обгорнутий тегом зі змістом, приклади:

- `<price>1.29</price>` - елемент price із значенням
- `<emptyTag></emptyTag>` - пустий елемент, або те саме `<emptyTag/>`
- `<price type="wholesale">1.29</price>` - атрибут `type` із значенням `wholesale`

Наведемо приклад XML документу: 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a comment -->
<bookstore>
  <book category="cooking">
    <title lang="en">Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>
  <book category="children">
    <title lang="en">Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>
</bookstore> 
```

Таким чином для того, щоб означити структуру документу для його розмічування використовують спеціальні коди, які називаються тегами (іноді також  маркерами). У наведеному прикладі `<bookstore>`,  `<book>` та  `<title>` та інше все є тегами, зміст яких починається з відкритого (початкового) тегу, наприклад `<book>` та обов'язково завершується закритим (кінцевим) тегом, наприклад  `</book>`. Назви тегів XML:

- можуть містити літери, цифри, дефіси, підкреслення та крапки але не можуть містити пробіли
- не можуть починатися з літер `xml` (або `XML`, або `Xml` тощо)
- повинні починатися з літери або підкреслення
- чутливі до регістру, наприклад тег `<Letter>` відрізняється від тега `<letter>`
- можуть містити нелатинські літери
- для розділення частин назви тегу рекомендується використовувати символ `_` або різний регістр літер  

Теги по факту є мітками для виділення певного іменованого змісту (`content`), які вони обрамляють. Зміст може бути звичайним текстом або містити інші XML-елементи чи комібнувати одне з іншим. Наприклад у наведеному вище прикладі значення поіменованої сутності `price` дорівнює `30.00`.   

Щодо текстового представлення змісту, там можуть бути будь які символи за винятком службових. На відміну від HTML пробіли не видаляються, мультирядкові тексти розділяються символом `LF`. Деякі символи є службовими в XML. Якщо ви розмістите символ на кшталт `<` всередині елемента XML, це спричинить помилку, оскільки аналізатор інтерпретує його як початок нового елемента. Щоб уникнути цієї помилки, спеціальні символи посиланням на сутність. У XML є 5 попередньо означених посилань на сутності:

| Необхідний символ | Замінник |
| ----------------- | -------- |
| <                 | `&lt;`   |
| >                 | `&gt;`   |
| &                 | `&amp;`  |
| '                 | `&apos;` |
| "                 | `&quot;` |

Окрім змісту, ці поіменовані сутності можуть мати певні властивості, які називають атрибутами (`attributes`). Ці властивості записують у форматі `ключ="значення"` або  `ключ='значення'` . У тега може бути довільна кількість атрибутів, які  записуються через пробіл. У наведеному вище прикладі  у одного з тегів `book` є два атрибути `category="computer"` і `subcategory="web"`.

Як вже зазанчалося, теги з їх змістом та формують XML елементи. Вкладеність елементів в інші елементи формують перегорнуте догори ногами дерево, яке починається з одного кореневого (root) елементу, який має дочірні (child) елементи які в свою чергу можуть мати дочірні елементи і так далі.

```xml
<root>
  <child>
    <subchild>.....</subchild>
  </child>
</root> 
```

Елемент може не мати вмісту, тоді він називається порожнім. У XML ви можете вказати порожній елемент так:

```xml
<element></element> 
```

або так:

```xml
<element /> 
```

Наведений вище код XML з `bookstore` можна відобразити графічно як на рис.8.2.     

![image-20221225215822444](xmljson/image-20221225215822444.png)

рис.8.2. Приклад дерева XML-документу.

Окрім самих даних, документ містить метадані в заголовку (Пролог `prolog`), що означує версію XML і [кодування](https://xmlwriter.net/xml_guide/xml_declaration.shtml) символів:

```xml
<?xml version="1.0" encoding="UTF-8"?>
```

Цей заголовок є декларацією XML і якщо він є, то має розташовуватися в першій позиції першого рядка і символи в нижньому регістрі. Окрім `version` та `encoding` може мати атрибути `standalone="yes"` що вказує на вміст в документі DTD (описано нижче).   

Коментарі починаються `<!--` і завершуються `-->`. Два тире в середині коментаря не допускаються. Приклад коментаря:

```xml
<!-- This is a comment -->
```

Для того щоб передавати текст без заміни заборонених символів посиланнями на сутності можна використовувати розділи CDATA. Ці розділи можуть з’являтися всередині вмісту елемента та дозволяти відображати наприклад символьні літерали `<` та `&`. Розділ CDATA починається з послідовності символів `<![CDATA[` і закінчується послідовністю символів `]]>`. Між двома послідовностями символів процесор XML ігнорує всі символи розмітки, такі як `<`, `>` і `&`. Єдина розмітка, яку XML-процесор розпізнає всередині розділу CDATA, це послідовність закриваючих символів `]>`. Тому послідовність символів, яка закінчує розділ CDATA `]]>`, не повинна з’являтися всередині вмісту елемента. Натомість завершальний символ `>` має бути екранований за допомогою відповідної сутності `&gt;`. Розділи CDATA не можуть бути вкладеними.

### Приклад розбору в Google Apps Scripts

Для роботи XML в усіх сучасних мовах та середовищах програмування надаються певні бібліотеки або сервіси.  У Google Apps Scripts наприклад, для роботи з XML є окремий вбудований сервіс [XML Service](https://developers.google.com/apps-script/reference/xml-service). Цей сервіс дозволяє сценаріям аналізувати, переглядати та програмно створювати документи XML. 

Для отримання об'єкту з XML використовується метод `parse`  в який в якості аргументу вставляється текстовий зміст, а результатом є об'єкт `Document`. Далі документ можна аналізувати або змінювати, використовуючи його методи. Можна доступатися до всіх вузлів через `getAllContent()` або до елементів (об'єкти класу `Element`), починаючи з кореневого `getRootElement()` а потім поступово вглиб до всіх дочірніх `getChildren()` або вказуючи назву елементів, до яких потрібно доступитися. Методи класу `Element` надають можливість доступатися до значення, змісту та атрибутів елементу. Нижче наведений приклад для демонстрації роботи деяких методів сервісу та його класів. 

```js
let xmlcontent = `<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a comment -->
<bookstore>
  <book category="cooking">
    <title lang="en">Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>
  <book category="children">
    <title lang="en">Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>
</bookstore>`
let document = XmlService.parse(xmlcontent);
let doccontents = document.getAllContent();
//наступний цикл виведе COMMENT та ELEMENT
for (let cont of doccontents){
  console.log (cont.getType().toString());
}
// отримати кореневий документ
let root = document.getRootElement();  
console.log (root.getName()); //виведе bookstore
// отримати усі дочірні елементи
let childrens = root.getChildren() ;
let child = childrens[0];
//наступне виведе [category='cooking']
console.log (child.getAttributes().toString()); 
//наступне виведе Everyday Italian
console.log (child.getChildren('title')[0].getValue()); 
```

### Простір імен

XML може повторно використовувати елементи/атрибути з інших XML-документів замість того, щоб створювати їх щоразу заново. Екземпляр XML може містити імена елементів або атрибутів з кількох документів XML. Неможливо буде зберегти унікальність елементів з різних документів, особливо при використанні чужого документа. Наприклад, у наступному фрагменті два елементи мають називатися  `address` але з різним контекстом:

```xml
<office>
    <address> Volodymyrska 68 </address>
    <address> 193.28.200.3 </address>
</office>
```

Простір імен — це спосіб вирішення конфліктів імен між різними джерелами елементів.

**Простір імен** (namespace) - це колекція доступних імен елементів і атрибутів XML, унікальних в межах цього простору, які ідентифікуються через посилання на той самий ідентифікатор простору імен. Цю колекцію часто називають "словником" XML, оскільки в ньому знаходяться переліки усіх доступних імен. Тобто вказівка простору імен вказує, що вимоги до змісту цього елементу обумовлюються вказаним простором імен. Таким чином в одному документі XML можуть бути кілька однакових імен але з різних просторів і таким чином вони будуть унікальні. 

Ось декілька ситуацій, коли простір імен корисний:

1. Імпорт інших XML-документів: Якщо ви вставляєте один XML-документ в інший, імена елементів і атрибутів можуть конфлікувати. Використання просторів імен дозволяє вам чітко вказати, який елемент належить до якого документу.
2. Використання сторонніх схем: Якщо ви використовуєте сторонні схеми, такі як XSD (XML Schema Definition), простір імен вказує, які елементи та типи даних використовуються зовнішньою схемою, що допомагає валідувати ваш XML.
3. Робота з різними додатками: Якщо різні додатки генерують XML-дані, простори імен дозволяють їм використовувати однакові імена, не спричиняючи конфліктів у результуючих даних.

Наприклад в наведеному вище прикладі, проблему можна б було вирішити добавивши до імен префікс адресного простору:  

```xml
<office>
    <post:address> Volodymyrska 68 </address>
    <net:address> 193.28.200.3 </address>
</office>
```

У якості ідентифікатору простору імен в XML використовують синтаксис URI (унікального ідентифікатора ресурсів), зокрема:

- URL (Uniform Resource Locators), наприклад, `https://www.w3schools.com`
- URN (Uniform Resource Names), наприклад, `urn:www-develop-com:student`

Варто зауважити що URI є чутливими до регістру. Хоч URL має формат посилання на ресурс в Інтернеті у даному випадку він є просто абстракцією, через яку теоретично можна унікально ідентифікувати простори імен. Формально ідентифікатор може бути довільним, але найважливішою властивістю простору імен є його унікальність. Автори можуть гарантувати унікальність URL-адреси, зареєструвавши наприклад доменне ім’я в Інтернеті і використовувати унікальні шляхи після  доменного імені. Далі цю адресу можна використовувати не тільки для ідентифікації, але і для опису самого простору імен.

Простори імен оголошуються як атрибути будь якого елемента документу XML за наступним синтаксисом. 

```xml
 <someElement xmlns:prefix=namespace/>
```

Ключове слово `xmlns` є зарезервованим і використовується лише з метою оголошення простору імен. Коли аналізатор XML зустрічає атрибути, що починаються з слова `xmlns` він розуміє, що це є атрибутом означення простору імен. Це слово пов'язує `prefix`, що йде після `xmlns:` з вказівником на простір імен, що є унікальним URI. По суті, кожен елемент тепер має назву з двох частин, ідентифікатор простору імен і локальну назву. Комбінацію цих двох імен часто називають іменем простору імен. Префікс використовується для скорочення посилання на цей простір імен далі в документі XML. Якщо в означенні `xmlns` префікс не вказано, то усі елементи без вказівки префіксу будуть використовувати даний простір імен за замовченням. Приклад означення та використання простору імен:  

```xml
<?xml version="1.0"?> 
<Book xmlns:lib="http://www.library.com"> 
    <lib:Title>Sherlock Holmes - I</lib:Title> 
    <lib:Author>Arthur Conan Doyle</lib:Author> 
</Book>
```

У даному прикладі будь-який елемент або атрибут, ім’я якого починається з префікса  `lib:`, вважається таким, що входить до простору імен `"http://www.library.com"`, якщо він  або предок має наведену вище декларацію простору імен. 

Коли в документах використовуються елементи або атрибути з кількох просторів імен, для певного елемента зазвичай є кілька декларацій простору імен, як показано в наступному прикладі:

```xml
<d:student xmlns:d='https://www.develop.com/student'
  xmlns:i='urn:schemas-develop-com:identifiers'
  xmlns:p='urn:schemas-develop-com:programming-languages'
>
  <i:id>3235329</i:id>
  <name>Jeff Smith</name>
  <p:language>C#</p:language>
  <d:rating>9.5</d:rating>
</d:student>
```

Тут елементи `student` і `rating` належать до одного простору імен, тоді як `id` і `language` - кожен з різного, а елемент `name` не належить до жодного простору імен. Якщо наприклад в наступному фрагменті коду на Google Apps Scripts (GAS) змінній `xmlcontent` присвоїти наведений вище xml, то за допомогою об'єкту класу `Namespace` можна отримувати інформацію про простір імен а також використовувати простір імен для фільтрації при виборі необхідних елементів. 

```js
let document = XmlService.parse(xmlcontent);
let root = document.getRootElement();  
let ns = root.getNamespace();
console.log (ns.getPrefix());// виведе d
console.log (ns.getURI()); //ввиведе https://www.develop.com/student
// наступний цикл вививде поступово 'i', '', 'p', 'd'
for (let child of root.getChildren()) {
  ns = child.getNamespace();
  console.log (ns.getPrefix());
}
```

Префікси простору імен також можна замінити, переоголосивши префікс у вкладеній області. 

Атрибути також можуть відноситися до певного простору імен:

```xml
<root xmlns:example="http://www.example.com/namespace">
  <element1 example:attribute1="Значення атрибуту 1">
    Зміст елемента 1
  </element1>
  <element2 example:attribute2="Значення атрибуту 2">
    Зміст елемента 2
  </element2>
</root>

```

У цьому прикладі, ми використовуємо адресний простір з префіксом `example`, який ми оголосили як `xmlns:example="http://www.example.com/namespace"` для елемента `root`. Потім ми використовуємо цей простір імен для атрибутів `example:attribute1` та `example:attribute2` для елементів `element1` та `element2`, відповідно. Це дозволяє нам чітко пов'язати атрибути з певним простором імен, щоб уникнути конфліктів імен і забезпечити коректне розуміння структури XML-документа.

Якщо ви оголошуєте простір імен для елемента, то всі дочірні елементи цього батьківського елемента, які не мають власної оголошеного простору імен, будуть належати до того ж простору імен, який оголошено для батьківського елемента. Оголошення простору імен для батьківського елемента стає дійсним для всіх його дочірніх елементів, поки вони самі не оголошують інший простір імен. Ось приклад:

```xml
xml
<root xmlns="http://www.example.com/namespace">
  <child1>Зміст дочірнього елемента 1</child1>
  <child2>Зміст дочірнього елемента 2</child2>
</root>
```

У цьому прикладі, елемент `root` оголошує простір імен з URI "http://www.example.com/namespace". Оскільки жоден з дочірніх елементів `child1` та `child2` не оголошує власний простір імен, вони автоматично належать до того самого простору імен, який оголошено для `root`. Простір імен можна оголошувати окремо для кожного дочірнього елемента, якщо потрібно змінити простір імен для окремих частин XML-структури.

В XML існують два аспекти, які можуть впливати на адресні простори імен елементів та атрибутів:

1. Простір імен елемента (Element Namespace): Якщо для елемента оголошується адресний простір за допомогою `xmlns` без префікса, цей простір імен застосовується до всіх дочірніх елементів цього батьківського елемента за замовчуванням.
2. Простір імен атрибута (Attribute Namespace): Атрибути не мають власних адресних просторів за замовчуванням і не належать до простору імен елемента, якщо вказано лише простір імен для самого елемента. Щоб прив'язати атрибут до певного простору імен, потрібно використовувати префікс для цього атрибута.

 Наприклад:

```xml
<root xmlns="http://www.example.com/namespace">
  <element attribute1="Значення атрибуту 1">
    Зміст елемента
  </element>
</root>
```

У цьому прикладі простір імен "http://www.example.com/namespace" застосовується до елемента `element`, але атрибут `attribute1` не має власного адресного простору і належить до простору імен елемента `element`.

Інший приклад:

```xml
<d:student xmlns:d='https://www.develop.com/student' xmlns='urn:foo' id='3235329'>
  <name>Jeff Smith</name>
  <language xmlns=''>C#</language>
  <rating>35</rating>
</d:student>
```

Тут `student` походить із простору імен `https://www.develop.com/student`, а `name` та `rating` — із простору імен за умовчанням `urn:foo`. Атрибут `id` не належить до простору імен, оскільки атрибути не пов’язуються автоматично з ідентифікатором простору імен за замовчанням.

### Опис документів та валідація

Як вже було зазначено, на відміну від мови HTML, в XML теги не мають певного заздалегідь означеного призначення. Однак при обміні даними між системами, призначення тегів має значення, адже під кожним тегом передбачається певна сутність, яка має атрибути, вкладені елементи і т.п. Тому системи повинні однаково розуміти їх, а структура документу повинна бути якимось чином описана. Маючи подібний опис, XML-документ може бути перевірений на коректність (валідність), що вказує на те, що його структура відповідає задуманій а перелік тегів та його властивостей коректний.

Для опису XML-документів використовують спеціальні описові формати що означують перелік полів даних, їх типи, ознаку обов’язковості, варіації версійності формату. Призначення таких описів документів – стандартизація форматів даних, що дозволяє налагодити беззбійний автоматичний обмін даними між комп’ютерними системами.  XML-документ із правильним синтаксисом називається "добре сформованим". XML-документ, перевірений на відповідність XML-схемі, є як "правильно сформованим", так і "дійсним".

Існують різноманітні формати опису XML-документів, далі розглянемо DTD та XSD, які є найбільш поширеними. Про них в наступних пунктах. 

## 8.3. Опис документів з використанням DTD

### Оголошення DTD

Означення формату **DTD** (Document Type Definition) є спадщиною від SGML. DTD оголошує глосарій усіх типів елементів документа, типи дочірніх елементів, а також порядок і номер кожного типу елемента. Він також оголошує будь-які атрибути, сутності, позначення, інструкції з обробки, коментарі та посилання в документі.

Для його використання він вказується в оголошенні типу документа (`!DOCTYPE`) , яке вказує що XML документ включає внутрішнє означення DTD або посилається на файл DTD.  У цьому випадку в декларації `!DOCTYPE` йде назва кореневого елементу XML, після чого йде оголошення формату між відкритою та закритою квадратною дужками, наприклад:  

```dtd
<?xml version="1.0" standalone="yes" ?>
<!DOCTYPE foo [
  <!ELEMENT foo (#PCDATA)>
]>
<foo> Hello World. </foo>
```

Зовнішні DTD корисні для створення спільного DTD, який можна використовувати для кількох документів. Будь-які зміни, внесені до зовнішнього DTD, автоматично оновлюють усі документи, які посилаються на нього. Існує два типи зовнішніх DTD: приватні та публічні. Приватні зовнішні DTD ідентифікуються ключовим словом `SYSTEM` і призначені для використання одним автором або групою авторів. Приклад оголошення:

```dtd
<!DOCTYPE root_element SYSTEM "DTD_location">
```

Де `DTD_location` відносний або абсолютний URL. 

Публічні зовнішні DTD ідентифікуються ключовим словом `PUBLIC` і призначені для широкого використання. Тут `DTD_location` використовується для пошуку публічного DTD, якщо його неможливо знайти за `DTD_name`:

```dtd
<!DOCTYPE root_element PUBLIC "DTD_name" "DTD_location">
```

### Елементи опису

У самому файлі DTD вказується тільки формат. До формату DTD входить оголошення зокрема (не повний перелік):

- `ELEMENT` -  типи елементів, типи дочірніх елементів, послідовність і їх кількість
- `ATTLIST` - перелік атрибутів
- `ENTITY` - перелік сутностей
- `NOTATION ` -  перелік нотаток 

Оголошення типу елемента встановлюють правила щодо типу та кількості елементів, які можуть з’являтися в XML-документі, які елементи можуть з’являтися один в одному та в якому порядку вони мають з’являтися в форматі.

```dtd
<!ELEMENT name допустимий_вміст>
```

Дозволеним вмістом типу елемента є `EMPTY`, `ANY`, змішаний або дочірні типи елементів:

- `EMPTY` - Вказує на тег, що має бути порожнім, тобто без змісту. Наприклад, порожній тег `IMG` з HTML може бути представлений одним із таких способів: `<IMG SRC="grommit.gif"/>` або `<IMG SRC="grommit.gif"></IMG>`
- `ANY` - Тег, зміст якого може бути будь якого типу, за умови дотримання правил XML. ANY корисно використовувати, коли вам ще потрібно вирішити допустимий вміст елемента.
- дочірні елементи в форматі `<!ELEMENT parent_name (child_names)>` - Можна розмістити будь-яку кількість типів елементів всередині іншого типу елемента. Вони називаються дочірніми елементами, а елементи, в які вони поміщені, називаються батьківськими.
- `#PCDATA` - Аналізовані символьні дані, тобто текст, який не є розміткою. Тому елемент із допустимим вмістом `(#PCDATA)` не може містити дочірніх елементів.
- Змішаний контент - Посилається на комбінацію `(#PCDATA)` і дочірніх елементів.

Оголошення батьківського і дочірніх елементів йде за форматом: 

```dtd
<!ELEMENT parent_name (child1_name,child2_name,child3_name)>
<!ELEMENT child1_name допустимий_вміст>
<!ELEMENT child2_name допустимий_вміст>
<!ELEMENT child3_name допустимий_вміст>
```

Кілька дочірніх елементів оголошуються за допомогою ком `,`. Коми фіксують послідовність, у якій дочірні елементи можуть з’являтися в документі XML. Усі дочірні елементи мають бути оголошені в окремій декларації типу елемента. 

Опційні дочірні елементи оголошуються за допомогою оператора `?`. Опційний означає що він повинен зустрітися нуль або один раз.

```dtd
<!ELEMENT parent_name (child_name?)>
<!ELEMENT child_name допустимий_вміст>
```

Нуль або більше дочірніх елементів оголошуються за допомогою оператора `*`.

```dtd
<!ELEMENT parent_name (child_name*)>
<!ELEMENT child_name допустимий_вміст>
```

Один або кілька дочірніх елементів оголошуються за допомогою оператора `+`.

```dtd
<!ELEMENT parent_name (child_name+)>
<!ELEMENT child_name допустимий_вміст>
```

Вибір між типами дочірніх елементів оголошується за допомогою оператора `|`.

```dtd
<!ELEMENT parent_name (child1_name|child2_name)>
<!ELEMENT child1_name допустимий_вміст>
<!ELEMENT child2_name допустимий_вміст>
```

Наведений нижче приклад містить дійсні оголошення вкладених елементів. Зверніть увагу що у прикладі використовується оголошення внутрішнього DTD. 

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE student [
  <!ELEMENT student (surname,firstname*,dob?,(origin|sex)?)>
  <!ELEMENT surname (#PCDATA)>
  <!ELEMENT firstname (#PCDATA)>
  <!ELEMENT sex (#PCDATA)>
]>
<student>
  <surname> Smith </surname>
  <firstname> Jo </firstname>
  <firstname> Sephine </firstname>
  <sex> female </sex>
</student>
```

У прикладі спочатку оголошується елемент з тегом `student`, який місить один `surname`, нуль або більше `firstname`, нуль або один `dob`, нуль або більше `origin` або `sex`. Кожен з дочірніх елементів містить будь який символьний набір які не аналізуються на розмітку (`#PCDATA`).

Оголошення `ATTLIST` означують, які типи елементів можуть мати атрибути, типи атрибутів і значення атрибутів за замовчуванням:

```xml-dtd
<!ATTLIST element_name attribute_name attribute_type default_value>
.
.
.
<element attribute_name="attribute_value">
```

де `element_name` -  ім'я елемента, до якого застосовується атрибут; `default_value` означає, чи потрібен атрибут чи ні, і якщо ні, яке значення за замовчуванням має відображатися: `#REQUIRED` - атрибут має завжди бути присутнім,  `#IMPLIED`  - не є обов'язковим, `FIXED 'Default_Value'` - Атрибут завжди повинен мати задане значення за умовчанням

Є три основні типи атрибутів: 

- `CDATA` - текстовий, означає символьні дані, тобто текст, який не формує розмітки.
- маркеровані типи які мають певне призначення, до них відносяться: `ID`, `IDREF`, `IDREFS`, `ENTITY`, `ENTITIES`, `NMTOKEN`, `NMTOKENS`
- перелічувані типи. 

У наступному прикладі для атрибутів `height` та `width` елементу `image` вказаний тип `CDATA` що вказує на текстовий зміст атрибуту.  

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE image [
  <!ELEMENT image EMPTY>
  <!ATTLIST image height CDATA #REQUIRED>
  <!ATTLIST image width CDATA #REQUIRED>
]>
<image height="32" width="32"/>
```

У якості маркерованого типу розглянемо `ID`  — це унікальний ідентифікатор атрибуту. Ідентифікатори зі значенням цього атрибуту не повинні з’являтися більше одного разу в документі XML. Атрибут типу `ID` може мати лише значення за замовчуванням `#IMPLIED` або `#REQUIRED`. У наступному прикладі атрибут `student_no`  елемента `student_name` повинен бути унікальним в межах документу і завжди бути присутнім.  

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE student_name [
  <!ELEMENT student_name (#PCDATA)>
  <!ATTLIST student_name student_no ID #REQUIRED>
]>
<student_name student_no="a9216735">Jo Smith</student_name>
```

Перелічувані типи атрибутів дозволяють робити вибір між різними значеннями атрибутів. У наступному прикладі для атрибуту `status` елементу `task` може бути одне з двох значень `important` або `normal`. 

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE ToDoList [
  <!ELEMENT ToDoList (task)*>
  <!ELEMENT task (#PCDATA)>
  <!ATTLIST task status (important|normal) #REQUIRED>
]>
<ToDoList>
  <task status="important">This is an important
    task that must be completed</task>
  <task status="normal">This task can wait</task>
</ToDoList>
```

Сутності (`ENTITY`) посилаються на дані, які діють як абревіатури або можуть бути знайдені у зовнішньому місці. Сутності допомагають зменшити введення інформації, що повторюється, а також дозволяють легше редагувати (шляхом зменшення кількості входжень даних для редагування). Оголошення сутностей виглядить наступним чином:

```xml-dtd
<!ENTITY name "entity_value">
```

де `name` - це посилання на сутність а `"entity_value"` це значення сутності. Таким чином в документі в змісті елементу можна вказувати не саме значення типу `#PCDATA` а посилання на нього через  синтаксис `&name`. Наприклад:

```xml-dtd
<?xml version="1.0" standalone="yes" ?>
<!DOCTYPE author [
  <!ELEMENT author (#PCDATA)>
  <!ENTITY js "Jo Smith">
]>
<author>&js;</author>
```

Є два типи декларацій сутностей: декларації сутностей `GENERAL` і оголошення сутностей `PARAMETER`.

Детальніше про DTD можна почитати [за посиланням](https://xmlwriter.net/xml_guide) 

## 8.4. Опис документів з використанням  XSD

### Основи XSD 

XSD (Означення схеми документу XML, XML Schema Definition) – набагато просунутіший і гнучкіший спосіб означення стандарту документу. XML Schema — це альтернатива DTD, яка базується на XML і використовує простір імен, і є більш потужною. 

Оскільки XML-схема – це також XML, як і документ, що на нього посилається, як і будь-який інший XML-документ, XML-схема складається з елементів і атрибутів. Цей «будівельний матеріал» має надходити з простору імен `http://www.w3.org/2001/XMLSchema`, який є оголошеним і зарезервованим простором імен, який містить елементи й атрибути, як означено в [W3C XML Schema Structures Specification ](http://www.w3.org/TR/xmlschema-1/) і [W3C XML Schema Datatypes Specification ](http://www.w3.org/TR/2001/REC-xmlschema-2-20010502). Використовуючи ці будівельні блоки можна створювати нові елементи та атрибути за потреби та накладати необхідні обмеження на ці елементи та атрибути та зберігати їх у певному просторі імен (рис.8.3). XML Schema називає цей конкретний простір імен цільовим простором імен (**target namespace**) або простором імен, де будуть знаходитися щойно створені елементи та атрибути.

![image-20221230133010316](xmljson/image-20221230133010316.png)

рис.8.3. Створення власного простору імен з використанням означення XML Schema Definition.

За такого підходу в кінцевому екземплярі XML документу (XML instance) посилаються на цей цільовий простір імен для забезпечення дійсності документа (рис.8.4). Під час перевірки валідатор перевіряє наявність елементів/атрибутів, які використовуються в екземплярі, у заявленому просторі імен, а також перевіряє наявність будь-яких інших обмежень щодо їх структури та типу даних, взявши файл схеми XSD за правило.

![image-20221230133443537](xmljson/image-20221230133443537.png)

рис.8.4. Від XML Schema до XML Schema instance

Розглянемо простий приклад XSD.

```xml
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
targetNamespace="https://www.w3schools.com"
xmlns="https://www.w3schools.com"
elementFormDefault="qualified">

<xs:element name="note">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="to" type="xs:string"/>
      <xs:element name="from" type="xs:string"/>
      <xs:element name="heading" type="xs:string"/>
      <xs:element name="body" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:element>

</xs:schema> 
```

Кореневим елементом кожної XSD має бути `<schema>` . Як вже зазначалося, атрибут `xmlns:xs="http://www.w3.org/2001/XMLSchema"` вказує на те, що елементи та типи даних, які використовуються в схемі, походять із простору імен `"http://www.w3.org/2001/XMLSchema"` та в даному випадку отримують префікс `xs`. Наступний атрибут `targetNamespace` вказує на те, що елементи, означені цією схемою (`note`, `to`, `from`, `heading`, `body` та інші) походять із простору імен `"https://www.w3schools.com"`. Атрибут `elementFormDefault` вказує на те, що будь-які елементи, які використовуються документом екземпляра XML і які були оголошені в цій схемі, повинні мати кваліфікований простір імен.  Далі означаються правила для елементів, які розглянуті нижче.  

Розглянемо екземпляр XML документу який посилається вказану вище на схему.

```xml
<?xml version="1.0"?>
<note
xmlns="https://www.w3schools.com"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="https://www.w3schools.com/xml note.xsd">
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note> 
```

Тег `note` в даному документі має три атрибути, кожен з яких рівний посиланню URI : `xmlns`, `xmlns:xsi` та `xsi:schemaLocation`. Як вже було сказано вище, ключове слово `xmlns` вказує на те, що атрибут задає простір імен. Якщо не вказано префікс, то це вказує на простір за замовченням (`"https://www.w3schools.com"`). Префікс `xsi` використовується для простору імен для екземпляру`"http://www.w3.org/2001/XMLSchema-instance"`. 

Для простору імен з префіксом `xsi` вказується ключове слово `schemaLocation`. Цей атрибут має два значення, розділених пробілом: перше — це простір імен для використання, а друге — це розташування XML-схеми для використання в цьому просторі імен:

```xml
xsi:schemaLocation="https://www.w3schools.com/xml note.xsd"
```

Таким чином валідатор зможе завантажити файл `note.xsd` і використовуючи правила, вказані в ньому перевірити екземпляр на валідність.

### Прості елементи

Схеми XML означують елементи файлів XML. Простий елемент (Simple Elements) — це елемент XML, який містить лише текст, він не може містити жодних інших елементів чи атрибутів. Текст в простих елементах може бути різних типів, включених у означення XML-схеми (логічне значення, рядок, дата тощо), або спеціального типу, який можна означити самостійно. В схемі також можна додати обмеження (фасети) до типу даних та відповідність певному шаблону. Означення простого елементу в схемі виглядить наступним чином:

```xml
<xs:element name="xxx" type="yyy"/> 
```

де `xxx` — ім’я елемента, а `yyy` — тип даних елемента. Схема XML має багато вбудованих типів даних. Найпоширеніші види:

- `xs:string` - див. також [XSD String Data Types](https://www.w3schools.com/xml/schema_dtypes_string.asp)
- `xs:decimal`, `xs:integer` -див. також [XSD Numeric Data Types](https://www.w3schools.com/xml/schema_dtypes_numeric.asp)
- `xs:boolean` - див. також [XSD Miscellaneous Data Types](https://www.w3schools.com/xml/schema_dtypes_misc.asp)
- `xs:date`, `xs:time` - див. також [XSD Date and Time Data Types](https://www.w3schools.com/xml/schema_dtypes_date.asp)

Ось приклад фрагменту екземпляру XML:

```xml
<lastname>Refsnes</lastname>
<age>36</age>
<dateborn>1970-03-27</dateborn> 
```

А ось відповідні прості означення даних елементів в схемі:

```xml
<xs:element name="lastname" type="xs:string"/>
<xs:element name="age" type="xs:integer"/>
<xs:element name="dateborn" type="xs:date"/> 
```

Означення типу даних для елементу або атрибуту накладає обмеження на їх вміст. Якщо, наприклад елемент XML має тип `"xs:date"` але містить рядок на зразок `"Hello World"`, елемент не буде валідним. За допомогою схем XML можна також додавати власні обмеження до елементів і атрибутів XML, які називають фасетами (див. нижче).

Прості елементи можуть мати значення за замовчуванням або вказане фіксоване значення. Значення за замовчуванням автоматично призначається елементу, якщо не вказано інше значення.  У наступному прикладі значенням за замовчуванням є `red`:

```xml
<xs:element name="color" type="xs:string" default="red"/> 
```

Фіксоване значення також автоматично призначається елементу, і ви не можете вказати інше значення. У наступному прикладі фіксованим значенням є `red`:

```xml
<xs:element name="color" type="xs:string" fixed="red"/> 
```

### Атрибути

Прості елементи не можуть мати атрибутів, бо якщо елемент має атрибути, він вважається комплексним елементом. Але сам атрибут завжди оголошується як простий тип. Синтаксис для означення атрибута:

```xml
<xs:attribute name="xxx" type="yyy"/> 
```

де `xxx` — ім’я атрибуту, а `yyy` — тип даних атрибуту.

Означення атрибуту дуже схоже на означення простого елементу. Використовуються типи даних з того ж переліку, можна означувати значення за замовченням та фіксовані значення. На додаток до цього можна вказувати обов'язковість атрибутів. За замовчуванням усі означені атрибути є необов'язковими.  Якщо необхідно щоб атрибут був обов'язковим у атрибуті означення атрибуту використовується ключове слово `use` зі значенням `"required"`: 

```xml
<xs:attribute name="lang" type="xs:string" use="required"/> 
```

### Обмеження та фасети

Обмеження використовуються для означення прийнятних значень для елементів або атрибутів XML. Обмеження на елементи XML називаються фасетами. Для означення обмежень, означують тип елементу, на який потім посилаються. Для простих елементів та атрибутів це робиться через елемент [`simpleType`](https://www.w3schools.com/xml/el_simpletype.asp). Наприклад у наступному прикладі XSD означено елемент під назвою `"age"` з обмеженням ([`restriction`](https://www.w3schools.com/xml/el_restriction.asp)), у якому значення може бути нижче 0 або більше 120:

```xml
<xs:element name="age">
  <xs:simpleType>
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="120"/>
    </xs:restriction>
  </xs:simpleType>
</xs:element> 
```

Нижче наведений перелік можливих обмежень:

| обмеження      | опис                                                         |
| -------------- | ------------------------------------------------------------ |
| enumeration    | Означує список прийнятних значень                            |
| fractionDigits | Вказує максимальну дозволену кількість знаків після коми. Має дорівнювати або бути більше нуля |
| length         | Означує точну дозволену кількість символів або елементів списку. Має дорівнювати або бути більше нуля |
| maxExclusive   | Означує верхню межу для числових значень (значення має бути меншим за це значення) |
| maxInclusive   | Означує верхню межу для числових значень (значення має бути менше або дорівнювати цьому значенню) |
| maxLength      | Означує максимальну дозволену кількість символів або елементів списку. Має дорівнювати або бути більше нуля |
| minExclusive   | Означує нижні межі для числових значень (значення має бути більшим за це значення) |
| minInclusive   | Означує нижні межі для числових значень (значення має бути більше або дорівнювати цьому значенню) |
| minLength      | Означує мінімальну допустиму кількість символів або елементів списку. Має дорівнювати або бути більше нуля |
| pattern        | Означує точну послідовність прийнятних символів              |
| totalDigits    | Вказує точну допустиму кількість цифр. Має бути більше нуля  |
| whiteSpace     | Означує, як обробляються пробіли (переведення рядків, табуляції, пробіли та повернення каретки). |

Детальніше про використання обмежень можна прочитати за [цим посиланням](https://www.w3schools.com/xml/schema_facets.asp).

### Комплексні елементи

Комплексні елементи (Complex Elements) - містить інші елементи та/або атрибути.  Існує чотири типи комплексних елементів:

-  порожні елементи, наприклад:

```xml
<product pid="1345"/> 
```

-  елементи, які містять лише інші елементи, наприклад:

```xml
<employee>
  <firstname>John</firstname>
  <lastname>Smith</lastname>
</employee> 
```

-  елементи, що містять лише текст, наприклад:

```xml
<food type="dessert">Ice cream</food> 
```

-  елементи, які містять як інші елементи, так і текст, наприклад:

```xml
<description>
It happened on <date lang="norwegian">03.03.99</date> ....
</description> 
```

Кожен із цих елементів також може містити атрибути. 

У схемі XML комплексний елемент можна означити двома шляхами. Наприклад, розглянемо наступний фрагмент екземпляру:

```xml
<employee>
  <firstname>John</firstname>
  <lastname>Smith</lastname>
</employee> 
```

Перший спосіб означення передбачає означення включених елементів прямо в структурі елементу  `xs:complexType` що є дочірнім для елементу `xs:element` через включені елементи `sequence`: 

```xml
<xs:element name="employee">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="firstname" type="xs:string"/>
      <xs:element name="lastname" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:element> 
```

Другий спосіб передбачає що створюється окремо `xs:complexType` з означенням його імені, на який потім просто посилаються.

```xml
<xs:element name="employee" type="personinfo"/>

<xs:complexType name="personinfo">
  <xs:sequence>
    <xs:element name="firstname" type="xs:string"/>
    <xs:element name="lastname" type="xs:string"/>
  </xs:sequence>
</xs:complexType> 
```

При використанні другого способу кілька елементів можуть посилатися на той самий складний тип, наприклад:

```xml
<xs:element name="employee" type="personinfo"/>
<xs:element name="student" type="personinfo"/>
<xs:element name="member" type="personinfo"/>

<xs:complexType name="personinfo">
  <xs:sequence>
    <xs:element name="firstname" type="xs:string"/>
    <xs:element name="lastname" type="xs:string"/>
  </xs:sequence>
</xs:complexType> 
```

## 8.5. Розбір і обробка XML документів

Для перетворення XML в об'єкти, з якими зручно працювати в коді програми, середовища програмування використовують парсери (розбірники) XML. Вище був розглянутий приклад коду в GAS, де цього використовується метод  `parse` об'єкту `XmlService`.

```js
let document = XmlService.parse(xmlcontent);
```

Є принаймні два підходи до такого парсингу: 

- DOM (Document object model) – парсер XML, який «завантажує», повністю відтворює об’єкт, описуваний в XML, в оперативній пам’яті, з усіма властивостями. Цей парсер вимагає набагато більше пам’яті і процесорного часу для обробки документів, але надає можливість працювати із об’єктом «цілком»
- SAX (Simple API for XML) – доволі простий парсер XML, що дозволяє здійснювати обробку документу методом траверсингу (руху від елементу до елементу) і не «будує» повну структуру документу в оперативній пам’яті. Цей парсер доволі швидкий, не вимагає великої кількості оперативної пам’яті і працює набагато швидше, ніж парсер DOM. 


У `XmlService.parse` наприклад використовується підхід DOM. На виході формується об'єкт [`Document`](https://developers.google.com/apps-script/reference/xml-service/document) який має набір методів для доступу до розпарсеного об'єкту як для читання так і для запису.

## 8.6. XSL, трансформація XSLT

**XSL** (Extensible Stylesheet Language) — це сімейство рекомендацій для означення перетворень і представлення XML документів. XSL складається із чотирьох частин:

- XML Path Language (XPath) - мова для виразів, використовується XSLT для доступу або посилання на частини XML документа. (XPath також використовується в специфікації XML Linking).
- XSL Transformations (XSLT) - мова для опису перетворень XML документів.
- XSL Formatting Objects (XSL-FO) - XML словник для описання семантики форматування.
- XQuery - мова для запитів документів XML

### XPath 

XPath використовує вирази шляху для вибору вузлів або наборів вузлів у документі XML. Ці вирази шляху дуже схожі на вирази, які ви бачите під час роботи з традиційною файловою системою комп’ютера. У XPath існує сім типів вузлів: елемент (element), атрибут (attribute), текст(text), простір імен(namespace), інструкція обробки (processing-instruction), коментар(comment) і кореневі вузли (root nodes). Документи XML розглядаються як дерева вузлів. Самий верхній елемент дерева називається кореневим елементом. 

Вузол вибирається за шляхом або кроками. Нижче наведено найбільш корисні вирази шляху:

| Вираз                       | Опис                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `nodename`                  | Вибирає всі вузли з назвою `nodename`                        |
| `/`                         | Вибирає з кореневого вузла                                   |
| `//`                        | Вибирає вузли в документі з поточного вузла, які відповідають виділенню незалежно від того, де вони знаходяться |
| `.`                         | Вибирає поточний вузол (контекстний)                         |
| `..`                        | Вибирає батьківський елемент для поточного вузла             |
| `@`                         | Вибирає атрибути                                             |
| `comment( )`                | Вибирає коментарі                                            |
| `text( )`                   | Вибирає текст CDATA                                          |
| `processing-instruction( )` | Вибирає інструкція обробки                                   |

Розглянемо приклад:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
    <book>
      <title lang="en">Harry Potter</title>
      <price>29.99</price>
    </book>
    <book>
      <title lang="en">Learning XML</title>
      <price>39.95</price>
</book>
</bookstore> 
```

У таблиці нижче перераховані деякі вирази шляху та результат виразів:

| Вираз             | Результат                                                    |
| ----------------- | ------------------------------------------------------------ |
| `bookstore`       | Вибирає всі вузли з назвою `bookstore`                       |
| `/bookstore`      | Вибирає кореневий елемент `bookstore` . Зверніть увагу, якщо шлях починається зі слеша `/`, він завжди представляє абсолютний шлях до елемента! |
| `bookstore/book`  | Вибирає всі елементи `book`, які є дочірніми для `bookstore` |
| `//book`          | Вибирає всі елементи `book` незалежно від того, де вони знаходяться в документі |
| `bookstore//book` | Вибирає всі елементи `book`, які є нащадками елемента `bookstore`, незалежно від того, де вони знаходяться під елементом `bookstore` |
| `//@lang`         | Вибирає всі атрибути з назвою `lang`                         |

Для пошуку конкретного вузла, або вузла, який містить певне значення використовуються предикати. Предикати завжди вкладаються в квадратні дужки, в яких записується умова істинності, яка означує умову вибору елементу. У таблиці нижче наведені деякі вирази шляху з предикатами та результат виразів:

| Вираз                                | Результат                                                    |
| ------------------------------------ | ------------------------------------------------------------ |
| `/bookstore/book[1]`                 | Вибирає перший елемент `book`, який є дочірнім елементом `bookstore`. |
| `/bookstore/book[last()]`            | Вибирає останній елемент `book`, який є дочірнім елементом `bookstore` |
| `/bookstore/book[last()-1]`          | Вибирає передостанній елемент `book`, який є дочірнім елементом `bookstore` |
| `/bookstore/book[position()<3]`      | Вибирає перші два елементи `book`, які є дочірніми елементами `bookstore` |
| `//title[@lang]`                     | Вибирає всі елементи `title`, які мають атрибут `lang`       |
| `//title[@lang='en']`                | Вибирає всі елементи заголовка, які мають атрибут `lang` зі значенням `"en"` |
| `/bookstore/book[price>35.00]`       | Вибирає всі елементи `book` в елементі `bookstore`, які мають елемент `price` зі значенням, вищим за `35,00` |
| `/bookstore/book[price>35.00]/title` | Вибирає всі елементи `title` елементів `book` в елементі книжкового `bookstore`, які мають елемент `price` зі значенням більше 35,00 |

Для вибору невідомих вузлів XML можна використовувати символи підстановки.

| Символи підстановки | Результат                                   |
| ------------------- | ------------------------------------------- |
| `*`                 | Відповідає будь-якому вузлу елемента        |
| `@*`                | Відповідає будь-якому вузлу атрибута        |
| `node()`            | Відповідає будь-якому вузлу будь-якого типу |

У таблиці нижче перераховані деякі вирази шляху та результат виразів:

| Вираз          | Результат                                                    |
| -------------- | ------------------------------------------------------------ |
| `/bookstore/*` | Вибирає всі дочірні вузли елемента `bookstore`               |
| `//*`          | Вибирає всі елементи в документі                             |
| `//title[@*]`  | Вибирає всі елементи заголовка, які мають принаймні один атрибут будь-якого типу |

Використовуючи оператор `|` (обчислення двох наборів вузлів) у виразі XPath, можна вибрати кілька шляхів, наприклад:

| Вираз                             | Результат                                                    |
| --------------------------------- | ------------------------------------------------------------ |
| `//book/title | //book/price`     | Вибирає всі елементи `title`  ТА `price` всіх елементів `book` |
| `//title | //price`               | Вибирає всі елементи `title`  ТА `price` в документі         |
| `/bookstore/book/title | //price` | Вибирає всі елементи `title` елемента `book` в елементі `bookstore` ТА всі елементи `price` в документі |

Крім `|` у XPath є багато різних операторів, зокрема:

- арифметичні: `+`, `-`, `*`, `div` (ділення), `mod` (остача від ділення)
- порівняння: `=`, `!=` (не дорівнює), `<`, `<=`, `>`, `>=`
- логічні: `and`, `or` 

Крім цього, в XPath є ряд функцій, з переліком яких можна ознайомитися, наприклад за [цим посиланням](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions). Наприклад вище була наведена функція `last()`, яка повертає ціле число, що дорівнює розміру контексту з контексту оцінки виразу. 

Вище ми розглянули скорочений синтаксис шляхів розташування. Однак XPath також пропонує нескорочений синтаксис для шляхів розташування, який є більш докладним, більш гнучким, але не таким використовуваним (не підтримується в XSLT). Кожен крок розташування в шляху розташування має три частини: вісь, перевірку вузла і предикати (необов'язкова). Вісь (axis) вказує у якому напрямку рухатися від контекстного вузла (де ми зараз знаходимся), щоб шукати наступні вузли. Перевірка вузлів повідомляє вам, які вузли слід включити вздовж цієї осі, а предикати додатково зменшують кількість вузлів відповідно до певного виразу. У скороченому шляху розташування вісь і перевірка вузла поєднуються, тоді як у нескороченому шляху розташування вони розділені подвійною двокрапкою `::`. 

```xml
axisname::nodetest[predicate] 
```

Наприклад, скорочений шлях розташування 

```xml
people/person/@id 
```

складається з трьох кроків розташування. Перший крок вибирає вузли елемента `people` уздовж дочірньої осі. На другому кроці вибираються вузли елемента `person` уздовж дочірньої осі. Третій крок вибирає вузли атрибутів ідентифікатора вздовж осі атрибутів. Якщо переписати з використанням нескороченого синтаксису, той самий шлях розташування буде:

```xml
child::people/child::person/attribute::id
```

Ці повні, нескорочені шляхи розташування можуть бути абсолютними, якщо вони починаються з кореневого вузла, так само як і скорочені шляхи. Наприклад, повна форма

```xml
/child::people/child::person
```

що еквівалентно

```
/people/person
```

### Загальні принципи XSLT

XSLT використовується для перетворення XML-документа в інший XML-документ або інший тип документа, який розпізнається браузером, наприклад HTML, XHTML або TXT. 

За допомогою XSLT можна додавати до вихідного файлу або видаляти з нього елементи та атрибути. Можна також змінювати порядок і сортувати елементи, виконувати тести та приймати рішення про те, які елементи приховувати та відображати, і багато іншого. Загальний спосіб опису процесу трансформації полягає в тому, що XSLT перетворює вихідний документ XML у новий документ XML (XHTML, TXT) використовуючи таблицю стилів XSLT (рис.8.5).

![image-20221225205059639](xmljson/image-20221225205059639.png)

рис.8.5. Принципи трансформації XSLT

Для означення пошукової інформації в документі XML механізм XSLT використовує скорочену форму XPath. У процесі трансформації XSLT використовує XPath для означення частин вихідного документа, які мають відповідати одному або декільком попередньо означеним шаблонам, що задані в таблиці стилів. Коли збіг знайдено, XSLT перетворить відповідну частину вихідного документа в кінцевий документ.

Кореневим елементом, який заявляє, що документ є таблицею стилів XSL, є `<xsl:stylesheet>` або `<xsl:transform>`, які є повними синонімами. Правильний спосіб оголошення таблиці стилів XSL згідно з рекомендацією W3C XSLT:

```xml
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> 
```

або

```xml
<xsl:transform version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> 
```

Щоб отримати доступ до елементів, атрибутів і функцій XSLT, необхідно оголосити простір імен XSLT у верхній частині документа. Запис `xmlns:xsl="http://www.w3.org/1999/XSL/Transform"` вказує на офіційний простір імен W3C XSLT. 

Кожне правило шаблону представлено елементом `xsl:template`. Цей елемент має атрибут `match`, який містить:

- шаблон XPath, що ідентифікує вхідні дані, яким він відповідає, використовуючи атрибут `match`; 
- сам шаблон, який створюється та виводиться

Для означення дій що необхідно зробити в шаблоні з вказаної вибірки використовуються спеціальні елементи адресного простору XSLT, зокрема:

- `xsl:value-of` - обчислює рядкове значення виразу XPath, означений в атрибуті `select` і вставляє його у вихідні дані
- `xsl:for-each` - перебирає кожен елемент, означений XPath в атрибуті `select`
- `xsl:sort` - сортує елементи за вказаним елементом в атрибуті `select`
- `xsl:apply-templates` - вказує порядок обробки

Перелік усіх елементів XSLT можна знайти за [цим посиланням](https://developer.mozilla.org/en-US/docs/Web/XSLT/Element)

### Приклад XSLT

Розглянемо [приклад](https://www.w3schools.com/xml/xsl_transformation.asp) перетворення XML-документу без форматування  "cdcatalog.xml" у XHTML. Нижче наведений фрагмент прикладу вихідного файлу XML без форматування:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <cd>
    <title>Empire Burlesque</title>
    <artist>Bob Dylan</artist>
    <country>USA</country>
    <company>Columbia</company>
    <price>10.90</price>
    <year>1985</year>
  </cd>
.
.
</catalog> 
```

Повний варіант наведений [за посиланням](https://www.w3schools.com/xml/cdcatalog.xml). Якщо його відкрити в браузері він буде показувати структуру документу по якому можна робити навігацію (відкривати/закривати гілки, тощо). Також в браузері можна подивитися вихідний файл. 

Для перетворення можна зробити файл з шаблоном з таблицею стилів XSL Style Sheet, який матиме вигляд:

```xml
<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
      <html>
      <body>
      <h2>My CD Collection</h2>
      <table border="1">
        <tr bgcolor="#9acd32">
          <th>Title</th>
          <th>Artist</th>
        </tr>
        <xsl:for-each select="catalog/cd">
            <tr>
              <td><xsl:value-of select="title"/></td>
              <td><xsl:value-of select="artist"/></td>
            </tr>
        </xsl:for-each>
      </table>
      </body>
      </html>
    </xsl:template>
</xsl:stylesheet> 
```

В елементі оголошення таблиці стилів є дочірній елемент `xsl:template`, який використовується для побудови шаблонів, що містить правила перетворення. Атрибут `match` використовується для асоціації шаблону з елементом XML з використанням XPath, тому запис `match="/"` вказує на те, що правило відноситься до всього документу.

Вміст всередині елемента `<xsl:template>` означає деякий код HTML для запису у вивід.  Елемент XSL `<xsl:for-each>` використовується для вибору кожного елемента XML із зазначеного набору вузлів зазначеного атрибутом `select`, який у прикладі вище містить вираз XPath. Такими чином `catalog/cd` вказує, що у вихідному документі треба перебрати усі дочірні елементи у елементі `cd` кореневого елементу `catalog` і зробити для них виведення, означене в межах елементу `for-each`. Елемент `<xsl:value-of>` використовується для отримання значення елемента XML і додавання його до вихідного потоку перетворення. У даному випадку для кожного елементу `catalog/cd` значення `title`  та `artist` записуються як поля у відповідних колонках.

Тепер можна підключити таблицю стилів у вихідний документ 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="cdcatalog.xsl"?>
<catalog>
  <cd>
    <title>Empire Burlesque</title>
    <artist>Bob Dylan</artist>
    <country>USA</country>
    <company>Columbia</company>
    <price>10.90</price>
    <year>1985</year>
  </cd>
.
.
</catalog> 
```

Якщо цей документ XML відкрити в браузері, сумісному з XSLT, він перетворить XML у XHTML відповідно до `cdcatalog.xsl`. Результат можна подивитися [за посиланням](https://www.w3schools.com/xml/cdcatalog_with_xsl.xml)

Вище був наведений приклад означення таблиці стилів прямо в файлі XML, який необхідно відобразити в браузері. Але часто необхідно перетворити один файл XML в інший XML, HTML, або інший текстовий документ, використовуючи файл XSL. Це дає можливість наприклад перетворювати документи XML різного формату в єдиний формат.  

## 8.7. Формат JSON

### Синтаксис

**JSON** ([JavaScript Object Notation](https://www.json.org/json-uk.html)) - це стандартний спосіб подання об'єкта JavaScript у вигляді рядку. Він часто використовується у веб-API для відправки та повернення даних а також для їх збереження, і має підтримку не тільки для середовищ JS а і для інших мов та середовищ.  При збереженні файлів їх розширення типово є ".json". Тип MIME при обміні по HTTP з використанням JSON є  "application/json" 

JSON побудований на двох структурах:

- Колекція пар `ключ:значення`. У різних мовах це реалізовано як об’єкт, запис, структура, словник, хеш-таблиця, список із ключем або асоціативний масив. Для JS це представлення об'єкту з його властивостями. 
- Упорядкований список значень. У більшості мов це реалізовано як масив (JS), вектор, список або послідовність.

Усі об'єкти що містять колекцію пар `ключ:значення`  беруться у фігурні дужки. Ось приклад порожнього об'єкту.

```json
{}
```

Властивості об'єкту типу ключ-значення записуються наступним чином:

```json
{"key1" : 23 , 
 "key2" : "24", 
 "key5" : {"key5_1": 37, 
           "key5_2": [123, 124]
          }
}
```

Ключі обов'язково беруться в подвійні лапки.

Масиви записуються з використанням квадратних дужок, в яких перераховуються елементи масиву:

```json
[10, "20", 30.7]
```

У якості елементів масиву можна використовувати різні типи даних: число, рядок, об'єкт, масив, true/false, null. Таким чином масиви та об'єкти можуть включати у свою чергу масиви та об'єкти.

```json
[10, "20", [30, 40], {"key1" : 23 , "key2" : "24"}]
```

Хоч JSON є текстовим представленням об'єктів JS він НЕ може містити в собі: функцій (методів), дати/часу, значення `undefined`. Крім того, він не може містити коментарі.

Якщо значення властивості має тип `string`, то не можна використовувати в середині символи подвійних лапок `"` а зворотня коса  `\` використовується в якості службового символу, що використовується для екранування та символів форматування:

- `"\""` - лапки
- `"\\"` - зворотня коса
- `"\/"` - коса
- `"\b"` - backspace
- `"\f"` - formfeed (зміна сторінки)
- `"\n"` - linefeed (зміна рядка)
- `"\r"` - повернення каретки
- `"\t"` - горизонтальна табуляція
- `"\u"` - для пердставлення Unicode символів в 16-ковій системі, наприклад `\u012A`

### JSON в порівнянні з XML

JSON і XML мають подібне призначення і виконують у більшості випадків однакові функції: 

- можуть читатися однаково як машиною так і людиною  
- мають ієрархічну природу (значення в середині інших значень)
- можуть бути розпарсені і використовуватися в різних мовах та середовищах програмування
- можуть передаватися в тілі повідомлення HTTP

JSON має переваги у своїй компактності, швидкості обробки, використанні окремого синтаксису для масиву і об'єкту. Крім того, у мові JS є вбудований клас `JSON`, який автоматично переводить текст JSON в об'єкт та навпаки (див.8.3), хоча в мові Java в базовий набір включена бібліотека для роботи з XML.  

На відміну від JSON, який є форматом даних, XML є мовою розмітки. Тобто XML є самоописовим документом (а не просто даними), в якому окрім самих даних є: метадані (дані про дані), простори імен, означення схеми. Це дає змогу перевірити документ XML на валідність та використати його в перетворенні в інші форми. Зокрема його можна навіть відобразити в зручній для користувача формі (XHTML), тоді як JSON не призначений для форматування зовнішнього вигляду. Крім того, документ XML може містити коментарі, підтримує більшу кількість типів даних для передачі (хоча все кодується як текст). Отже, хоч XML є набагато старішим форматом, він разом з обробниками надає більше функцій ніж передбачено в JSON.  

![image-20230103103231568](xmljson/image-20230103103231568.png)

рис.8.1. Приклад представлення даних у вигляді документу XML (ліворуч) та JSON (праворуч).

## 8.8. Валідація JSON

Як зазначалося в попередній лекції, при передачі даних важливо, щоб їх структура відповідала очікуваній, інакше розподілена система буде не належним чином функціонувати, або взагалі перестане працювати. Хоч JSON першопочатково розроблений без передбачення валідації, існують певні рішення для цього, наприклад [JSON Schema](https://json-schema.org/). JSON Schema — це інструмент для перевірки структури даних JSON, який наразі є чорновим варіантом, а не стандартом. Остання версія JSON Schema доступна на сайті https://json-schema.org.  Існують також системи реєстрації схем JSON для автоматичної валідації JSON об’єктів в момент передачі даних між системами.

JSON Schema має наступне призначення:

- Описує існуючі формати даних
- Надає чітку документацію, яку можна зчитувати людиною та машиною.
- Перевіряє дані, корисні для:
  - Автоматизованого тестування
  - Забезпечення якості наданих клієнтом даних

Схема JSON означує: 

- media type `application/schema+json` як формат на основі JSON для опису структури даних JSON; 
- вигляд документу JSON; 
- способи отримання з нього інформації та способи взаємодії з ним. 

Розглянемо принципи валідації на прикладі. Припустимо, маємо наступні дані в форматі JSON: 

```json
{
  "subjects": [
    {
      "name": "math",
      "description": "Elementary Math",
      "hours": 25
    },
    {
      "name": "chemistry",
      "description": "Elementary Chemistry",
      "hours": 15
    }
  ],
  "tutors": [
    {
      "type": "main",
      "firstName": "Olexander",
      "lastName": "Olexenko"
    },
    {
      "type": "substitute",
      "firstName": "Roman",
      "lastName": "Romanenko"
    }
  ]
}
```

Припустимо, необхідно описати наведену вище структуру в форматі JSON Schema. Фрагмент схеми може мати вигляд:

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "$id": "http://iasu-nuft.pp.ua/schemas/schemaexmpl.json",    
  "type": "object",
  "properties": {
    "subjects": {
      "type": "array",
      "items": [
        {"type": "object",
          "properties": {
            "name": {"type": "string"},
            "description": {"type": "string"},
            "hours": {"type": "integer"}
         },
          "required": ["name","description", "hours"]
        }
      ]
    },
    "tutors": {
      "type": "array",
      "items": [ 
      ...
      ]
    }
  },
  "required": [
    "subjects",
    "tutors"
  ]
}
```

Це об'єкт, який має першу властивість `$schema`, яка вказує на версію JSON Schema. Це схоже на посилання на простір імен `xmlns` в XML. Вказуючи на схему Ви означуєте її версію. Крім версійності JSON Schema можна також вказати унікальний ідентифікатор самої схеми, для чого використовується властивість `$id`.

Далі йде властивість `type`, яка означує тип даних для кореневого об'єкту. Доступні такі типи: string, number, integer, object, array, boolean, null. Як видно, на відміну від JS, є окремо типи `array` та `integer`. 

У даному прикладі кореневим елементом є `object`. Тому для нього треба означити властивості, через властивість  `properties`.  Значення `properties`— це об’єкт, де кожен ключ — це ім’я властивості, а кожне значення — це схема, яка використовується для перевірки цієї властивості. Будь-яка властивість, яка не відповідає жодній назві властивості в ключовому слові `properties`, ігнорується цим ключовим словом. У наведеному прикладі кореневий об'єкт має властивості  `subjects` та `tutors`, тому далі йде означення їх схеми. 

За замовчуванням властивості, означені ключовим словом `properties`, не є обов'язковими. Однак можна надати список необхідних властивостей за допомогою ключового слова `required`. Воно приймає масив із нуля або більше рядків, які задають перелік обов'язкових властивостей. У наведеному прикладі властивості  `subjects`  та `tutors` означені як обов'язкові. 

Означення властивості йде за тією ж схемою. Спочатку вказується тип, якщо він  `object`, то далі вказується означення властивостей. Якщо це `array` то вказується вимога до елементів через ключове слово `items` де у вигляді масиву задаються схеми для кожного елменту. Якщо це необ'єктний тип, то на вказівці типу означення може завершитися.    

Наведений вище приклад є демонстраційним і не показує усі можливості JSON Schema. 

## 8.9. JSON об'єкт в JS

Як вже зазначалося для роботи з JSON в JS є вбудований однойменний об'єкт. Він має всього два методи:

- `parse` - для отримання JS об'єкту з JSON 
- `stringify` - для серіалізації об'єкту в JSON

Ось простий приклад для роботи `parse`:

```js
const obj = JSON.parse('{"name":"John", "age":30, "city":"New York", "kids": ["Elvis", "Rita"]}');
console.log (obj.kids.length);//2
```

Інший формат методу:

```js
JSON.parse(text, reviver)
```

де `reviver` - функція яка викликається після парсингу кожного значення для наступної обробки перед поверненням результату. Функція викликається з такими аргументами:

- `key` - ключ, що асоціюється зі значенням       
- `value` - значення після парсингу

Для розуміння послідовності обробки кожного значення можна викликати наступний фргамент коду в JS:

```js
const obj = JSON.parse('{"name":"John", "age":30, "city":"New York", "kids": ["Elvis", "Rita"]}', 
  function (key, value) {console.log (key + ' ' + value)});
```

він виведе наступне:

```
name John
age 30
city New York
0 Elvis
1 Rita
kids ,
[object Object]
```

Як видно, обробка відбувається з кінцевих елементів в напрямку руху до кореневого. Ось приклад використання reviver-функції для обробки дати. 

```js
const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
const obj = JSON.parse(text, function (key, value) {
  if (key == "birth") {
    return new Date(value);
  } else {
    return value;
  }
});
```

Як вже зазначалося, методи (функції) як частина серіалізованого об'єкту не підтримуються в JSON. Але можна їх передавати у вигляді тексту і потім викликати через `eval`, як це показано в наступному прикладі.

```js
var text = `{"name":"John", "birth":"1986-12-14", "city":"New York",
"age":"function () {return ((new Date() - new Date(this.birth))/(365*24*60*60000))}"}` 
const obj = JSON.parse(text);
obj.age = eval("(" + obj.age + ")");
console.log (obj.age());
```

Метод `stringify` перетворює об'єкт JS в рядок. Наприклад:   

```js
const obj = {name: "John", age: 30, city: "New York", kids: ["Elvis", "Rita"]};
const myJSON = JSON.stringify(obj);
```

Значення `undefined`, `Function` і `Symbol` не є дійсними значеннями JSON. Якщо такі значення зустрічаються під час перетворення, вони або пропускаються (якщо знайдено в об’єкті), або змінюються на `null` (якщо знайдено в масиві). Наприклад даний код в JS/GAS виведе те, що вказано в коментарі:

```js
const obj = {name:"John", 
birth:"1986-12-14", 
city:"New York",
age: function () {return ((new Date() - new Date(this.birth))/(365*24*60*60000))}
}
const myJSON = JSON.stringify(obj);
console.log (myJSON); // виведе {"name":"John","birth":"1986-12-14","city":"New York"}
```

Натомість можна скористатися методом `toString ()`:

```js
const obj = {name:"John", 
birth:"1986-12-14", 
city:"New York",
age: function () {return ((new Date() - new Date(this.birth))/(365*24*60*60000))}
}
obj.age = obj.age.toString();
const myJSON = JSON.stringify(obj);
console.log (myJSON);
//виведе {"name":"John","birth":"1986-12-14","city":"New York","age":"function () {return ((new Date() - new Date(this.birth))/(365*24*60*60000))}"}
```

Метод `stringify` має ще дві форми виклику:

```js
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
```

де:

-  `replacer` - це замінник що є функцією або масивом, які змінюють поведінку процесу серіалізації. Якщо замінник є масивом елементів `string` то їх значення буде використовуватися як назва ключів, які будуть використовуватися при серіалізації об'єкту, тобто значення інших властивостей не будуть серіалізуватися.  Якщо це буде функція, то вона приймає два параметри: ключ і значення, яке перетворюється в string. Об’єкт, у якому було знайдено ключ, надається як замінник цього контексту. 
-  `space` - рядок або число, яке використовується для вставлення пробілів або інших символів (включно з відступами, символами розриву рядка тощо) у вихідний рядок JSON для зручності читання. Якщо це число, воно вказує кількість символів пробілу, які будуть використовуватися як відступи (від 0 до 10). Якщо це рядок то перші 10 символів рядка вставляється перед кожним вкладеним об’єктом або масивом. 

Нижче наведений приклад використання `replacer` як масиву:

```js
const foo = {foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7};
console.log (JSON.stringify(foo, ["week", "month"]));// {"week":45,"month":7}
```

Наступний фрагмент коду `replacer` як функції:

```js
const foo = {ob: {a:1, b:2}, model: "box", week: 45, transport: "car", month: 7};
let jsonrez = JSON.stringify(foo, function (key, value) { 
  console.log (key + ' = ' + value);
  if (typeof value === "string") {
    return undefined;
  }
  return value});
console.log (jsonrez); 
```

поверне такий результат:

```
 = [object Object]
ob = [object Object]
a = 1
b = 2
model = box
week = 45
transport = car
month = 7
{"ob":{"a":1,"b":2},"week":45,"month":7}
```

Як видно,  `replacer` повертає значення властивостей об'єкту починаючи з кореня, тому перший вивід вивів пусте значення назви ключа.

У наступному фрагменті використовується аргумент `space` 

```js
console.log(JSON.stringify({a:1, c:[1,[2,3]]}));
console.log(JSON.stringify({a:1, c:[1,[2,3]]}, null, 1));
console.log(JSON.stringify({a:1, c:[1,[2,3]]}, null, ">"));
```

Він видає наступний результат:  

```
{"a":1,"c":[1,[2,3]]}
{
 "a": 1,
 "c": [
  1,
  [
   2,
   3
  ]
 ]
}
{
>"a": 1,
>"c": [
>>1,
>>[
>>>2,
>>>3
>>]
>]
}
```

## 8.10. JSONata

[JSONata](https://jsonata.org/) — це мова запитів і перетворення даних JSON, яка була розроблена за натхнення семантики XPath, яка розглядалася на минулій лекції. JSONata дозволяє виражати складні запити на вибірку в компактній та інтуїтивно зрозумілій нотації. Основна ідея в тому щоб з вихідних даних JSON отримати необхідні дані, перетворити їх у потрібну форму (об'єднати, скомпонувати) і видати результат. Для підтримки вилучення значень зі структури JSON означений синтаксис шляху розташування. Це дозволяє вибрати всі можливі значення в документі, які відповідають вказаному шляху розташування (location path). 

Для розуміння роботи JSONata можна перевірити наведені приклади, перейшовши на сайт http://try.jsonata.org/ . У вікні ліворуч можна вибрати приклад вихідного документу зі списку, або вписати свій. У якості типового прикладу в лекції буде використовуватися Address.

### Прості запити на вибірку

У якості прикладу розглянемо наступний вихідний документ (вибирається на  http://try.jsonata.org/ як Address):

```json
{
  "FirstName": "Fred",
  "Surname": "Smith",
  "Age": 28,
  "Address": {"Street": "Hursley Park", "City": "Winchester", "Postcode": "SO21 2JN"},
  "Phone": [
    {"type": "home", "number": "0203 544 1234"},
    {"type": "office", "number": "01962 001234"},
    {"type": "office","number": "01962 001235"},
    {"type": "mobile","number": "077 7700 1234"}
  ],
  "Email": [
    {"type": "work", "address": ["fred.smith@my-work.com", "fsmith@my-work.com"]},
    {"type": "home", "address": ["freddy@my-social.com", "frederic.smith@very-serious.com"]}
  ],
  "Other": { "Over 18 ?": true, "Misc": null, "Alternative.Address": { "Street": "Brick Lane", "City": "London", "Postcode": "E1 6RF"}
  }
}
```

Для вказівки шляху розташування необхідно використовувати синтаксис пошуку об'єктів, їх властивостей, масивів та їх елементів. Пошук починається з кореневого об'єкту, до якого за необхідності можна звернутися через `$$`. Тому, якщо в шляху вказати якесь слово, буде шукатися властивість в кореневому об'єкті. Якщо потрібно знайти щось у включеному об'єкті, то необхідно прописати шлях доступу до нього. Якщо потрібно вказати елемент масиву, до нього йде звернення аналогічно як в JS, наприклад `Phone[0]`. Якщо звернення йде до назви масиву, або не вказується індекс, повертаються усі елементи масиву. Негативне значення індексу в масиві шукає значення відраховане з кінця, наприклад `arr[-1]` бере останній елемент, а `arr[-2] ` - бере передостанній.  При пошуку полів з пробілами вони вказуються в спеціальних лапках ` `` `.    

У таблиці 8.1 показні прості приклади задавання пошуку в ``JSONata``. 

Таблиця 8.1.

| **JSONata**       | **Result**                                       |
| ----------------- | ------------------------------------------------ |
| `Surname`         | `"Smith"`                                        |
| `Age`             | `28`                                             |
| `Age[0]`          | `28`                                             |
| `Address.City`    | `"Winchester"`                                   |
| `Other.Misc`      | `null`                                           |
| `Other.Over 18 ?` | `true`                                           |
| `Phone[0]`        | `{ "type": "home", "number": "0203 544 1234" }`  |
| `Phone[-2]`       | `{ "type": "office", "number": "01962 001235" }` |
| `Phone[8]`        | *undefined*                                      |
| `Phone[0].number` | `"0203 544 1234"`                                |

Слід зазначити, що пошук відбувається рекурсивно. Тобто, якщо задати в пошуку назву масиву об'єктів, і при цьому звертатися до властивості цих об'єктів, то результатом буде масив властивостей усіх елементів масиву. Це можна представляти так: спочатку пошук поверне масив усіх об'єктів, а потім зробить пошук у кожному елементі потрібних властивостей і поверне їх в цьому масиві замість всього об'єкту. У таблиці 8.2 показаний приклад такого звернення `Phone.number`.

За цією ж ідеєю можна звернутися до елементу з поверненого результату. У таблиці 8.2 показаний приклад такого звернення `(Phone.number)[0]`, який можна пояснити так:

- вибираємо усі елементи `Phone` -> масив об'єктів `Phone` 
- вибираємо з кожного елементу `Phone` властивість `number` -> масив `Phone.number` 
- вибираємо 0-й елемент з `Phone.number` 

Але зверніть увагу, що в даному прикладі `Phone.number` треба поставити в дужки `()` для пріоритизації послідовності пошуку. Інакше, якщо звернутися як `Phone.number[0]`, то алгоритм буде наступний:

- вибираємо усі елементи `Phone` -> масив об'єктів `Phone` 
- вибираємо з кожного елементу `Phone` властивість `number[0]` -> масив `Phone.number` 

Хоч `number` в `Phone` не є формально масивом, звернення до 0-го елементу аналогічно зверненню до самого елементу. Тобто у виразі або підвиразі JSONata будь-яке значення яке не є масивом і масив, що містить тільки це значення, вважаються еквівалентними. Це дозволяє складати композицію таким чином, щоб шляхи розташування, які витягують одне значення з об'єктів і шляхи розташування, які витягують декілька значень з масивів, можуть бути використані як вхідні дані для інших виразів без використання іншого синтаксису для двох форм. 

Таблиця 8.2.

| **JSONata**         | **Result**                                                   |
| ------------------- | ------------------------------------------------------------ |
| `Phone.number`      | `[ "0203 544 1234", "01962 001234", "01962 001235", "077 7700 1234" ]` |
| `(Phone.number)[0]` | `"0203 544 1234"`                                            |
| `Phone.number[0]`   | `[ "0203 544 1234", "01962 001234", "01962 001235", "077 7700 1234" ]` |

На кожному рівні такого пошуку ми маємо певний результат, який називається контекстом і позначається як `$` . На самому початку контекстом є весь документ, і як вже зазначалося, він має також спеціальне позначення `$$`. Це легко перевірити, вписавши ці символи в  http://try.jsonata.org/ . Обидві ці системні змінні можна використовувати для організації складніших запитів. Однак, коли кореневим елементом є масив, звернутися до його елементу можна тільки через них.   

Візьмемо приклад:

```json
[{ "ref": [ 1,2 ] },{ "ref": [ 3,4 ] }]
```

Якщо ми хочемо вибрати перший (0-й) об'єкт у цьому масиві, то необхідно вказати назву об’єкту верхнього рівня, до якого треба додати [0]. Ми не можемо використовувати [0] самостійно, тому що стикаємося з синтаксисом конструктора масиву. Однак, ми можемо використовувати посилання контексту `$` для посилання на початок документа наступним чином (таблиця 8.3)

Таблиця 8.3.

| **JSONata**     | **Result**           | **Коментар**                                                 |
| --------------- | -------------------- | ------------------------------------------------------------ |
| `$[0]`          | `{ "ref": [ 1,2 ] }` | `$` на початку виразу відноситься до всього вхідного документа |
| `$[0].ref`  ` ` | `[ 1,2 ] `  ` `      | `.ref` тут повертає  весь внутрішній масив                   |
| `$[0].ref[0]`   | `1`                  | повертає елемент на  першу позицію внутрішнього масиву       |
| `$.ref`         | `[ 1, 2, 3, 4 ]`     | Незважаючи на  структуру вкладеного масиву, результуючий вибір сплющується в один плоский  масив. Початкова вкладена структура вхідних масивів втрачається. |

### Предикативні запити 

На будь-якому кроці шляху розташування виділені елементи можуть бути відфільтровані за допомогою **предиката** - `[expr]`, де `expr` аналізується як вираз, що повертає булеве значення. Кожен елемент у виділенні перевіряється як вираз, якщо він дорівнює `true`, то елемент залишається у виділенні, якщо `false`, він видаляється з виділення. Вираз оцінюється відносно поточного (контекстного) елемента, що перевіряється, тому, якщо вираз предиката виконує навігацію, то вона проводиться відносно цього контексту. У таблиці 8.4 показні приклади предикатів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (виберіть приклад Address).

Приклад:

```json
{"Phone": [
    {"type": "home", "number": "0203 544 1234"},
    {"type": "office","number": "01962 001234"},
    {"type": "office","number": "01962 001235"},
    {"type": "mobile","number": "077 7700 1234"}]
}
```

Таблиця 8.4.

| **JSONata**                      | **Result**                                        |
| -------------------------------- | ------------------------------------------------- |
| `Phone[type='mobile'] `          | `{"type": "mobile", "number": "077 7700 1234" } ` |
| `Phone[type='mobile'].number`    | `"077 7700 1234"`                                 |
| `Phone[type='office'].number`` ` | `["01962 001234", "01962 001235"] `               |

Як вже зазначалося у виразі або підвиразі JSONata будь-яке значення (яке не є масивом) і масив, що містить тільки це значення, вважаються еквівалентними.  Наприклад (див вихідний текс JSON вище):

- `Address.City` повертає `"Winchester"`
- `Phone[0].number`  повертає `"0203 544 1234"`
- `Phone[type='home'].number`  повертає `"0203 544 1234"`
- `Phone[type='office'].number` повертає`["01962 001234", "01962 001235"]`

При наступній обробці поверненого з вираження JSONata значення, може бути бажаним мати результати в узгодженому форматі, незалежно від того, скільки співпадінь було і відповідно який формат поверненого значення (масив або одне значення). У перших двох виразах вище, очевидно, що кожен вираз звертається до одного значення в структурі і має сенс повернути саме це значення. В останніх двох виразах, однак, не є очевидним, скільки значень буде повернено, тому при наступній обробці прийдеться враховувати різні формати, що не є зручним. Для таких випадків вираз можна змінити таким чином, щоб повернути масив, навіть якщо збігається лише одне значення. Це робиться шляхом додавання порожніх квадратних дужок `[]` до кроку в шляху розташування. Наведені вище приклади можуть бути переписані так, щоб завжди повертати масив, це виглядає наступним чином:

- `Address[].City` повертає `[ "Winchester"]`
- `Phone[0][].number` повертає `[ "0203 544 1234" ]`
- `Phone[][type='home'].number` повертає `[ "0203 544 1234" ]`
- `Phone[type='office'].number[] `повертає `[ "01962 001234", "01962 001235" ]`

Зауважимо, що `[]` можна розмістити у будь-якому місці предикатів і на будь-якому кроці вираження шляху

Для вибору всіх полів в об'єкті можна використовувати `*` замість імені поля. У таблиці 8.5 показні приклади предикату `*`. Можна перевірити ці приклади, перейшовши на сайт http://try.jsonata.org/ (виберіть приклад Address). Приклад:

```json
{
  "FirstName": "Fred",
  "Surname": "Smith",
  "Age": 28,
  "Address": {
    "Street": "Hursley Park",
    "City": "Winchester",
    "Postcode": "SO21 2JN"
  }
}
```

 Таблиця 8.5.

| **JSONata**   | **Result**                                      |
| ------------- | ----------------------------------------------- |
| `Address.*`   | `[ "Hursley Park", "Winchester", "SO21 2JN" ] ` |
| `*.Postcode ` | `"SO21 2JN" `                                   |

Шаблон нащадка `**` замість `*` буде відбирати всіх нащадків (багаторівневий шаблон). Для прикладу з таблиці 8.1 

`**.Postcode` поверне `[ "SO21 2JN", "E1 6RF" ]`

### Вирази та оператори

У виразах шляху можна використовувати літеральні константи, помістивши символи в лапки: подвійні `"` або одинарні `'` (як і рядки JSON). Рядки можна комбінувати за допомогою оператора конкатенації `&`, цей оператор поєднує два рядки, які повертаються виразами. Це єдиний оператор, який намагатиметься збирати операнди разом до очікуваного рядкового типу. У таблиці 8.6 показні приклади оператору `&`. Можна перевірити ці приклади, перейшовши на сайт http://try.jsonata.org/ (виберіть приклад Address).  Приклад:

```json
{
  "FirstName": "Fred",
  "Surname": "Smith",
  "Age": 28,
  "Address": {
    "Street": "Hursley Park",
    "City": "Winchester",
    "Postcode": "SO21 2JN"
  }
}
```

Таблиця 8.6.

| **JSONata**                       | **Result**                    |
| --------------------------------- | ----------------------------- |
| `FirstName & ' ' & Surname`       | `"Fred Smith" `               |
| `Address.(Street & ', ' & City) ` | `"Hursley Park, Winchester" ` |
| `5&0&true `                       | `"50true"`                    |

Вирази шляхів, які вказують на числове значення, повернуть це значення як числовий тип. JSONata також може використовувати числові контстанти за тими ж правилами, що і для JSON-чисел. Числові літетерали та вирази можуть бути використані в розрахунках результатів з використанням звичайних математичних операторів. Підтримувані оператори:

- `+` додавання
- `-` віднімання
- `*` множення
- `/` ділення
- `%` остача від ділення 

У таблиці 8.7 показні приклади арифметичних операторів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (скопіюйте приклад в поле Exerciser).   Приклад:

  ```json
{ "Numbers": [1, 2.4, 3.5, 10, 20.9, 30] }
  ```

Таблиця 8.7.

| **JSONata**                 | **Result**       | **Коментар**       |
| --------------------------- | ---------------- | ------------------ |
| `Numbers[0] + Numbers[1]`   | `3.4`            | додати 2 числа     |
| `Numbers[0] - Numbers[4]`   | `-19.9`          | віднімання         |
| `Numbers[0] * Numbers[5]`   | `30`             | множення           |
| `Numbers``[0] / Numbers[4]` | 0.04784688995215 | ділення            |
| `Numbers``[2] % Numbers[5]` | 3.5              | остача від ділення |

В предикатах можна використоувати оператори порівняння двох значень, які повертають логічні значення `true` або `false`. Підтримувані оператори:

- `=` дорівнює
- `!=` не дорівнює
- `<` менше ніж
- `<=` менше ніж чи дорівнює
- `>` більше ніж
- `>=` більше або дорівнює ніж
- `in` значення міститься в масиві

Для об'єднання булевих результатів для підтримки більш складних предикатних виразів можна використати булеві оператори:

- `and`
- `or`

Зверніть увагу, що `not` підтримується як функція ([$not](http://docs.jsonata.org/boolean-functions#not)), а не оператор. У таблиці 8.8 показні приклади булевих виразів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (скопіюйте приклад в поле Exerciser). Таблиця 8.8.

```json
{"Numbers": [1, 2.4, 3.5, 10, 20.9, 30]}
```

| **JSONata**                                         | **Result** |
| --------------------------------------------------- | ---------- |
| `(Numbers[2]  != 0) and (Numbers[5] != Numbers[1])` | *false*    |
| `(Numbers[2]  != 0) or (Numbers[5] = Numbers[1])`   | *true*     |

### Структурування результату 

Окрім вибірки значень JSONata дає можливість компонування кількох результатів в один масив або об'єкт.

Як зазначалося раніше, якщо шлях розташування у вхідному документі відповідає декільком значенням, ці значення повертаються як масив. Значення у документі можуть бути як об'єктами так і масивами, але значення що повертаються знаходяться на верхньому рівні у вигляді масиву.

Можна побудувати додаткову структуру в результуючому масиві, вказавши у виразі шляху розташування конструктор масивів (або об'єктів). У будь-якій точці шляху розташування, де очікується посилання на поле, можна вставити пару квадратних дужок `[]`, щоб вказати, що результати вираження в цих дужках повинні міститися в новому масиві на виході. Коми використовуються для розділення декількох виразів у конструкторі масиву. У таблиці 8.9 показні приклади конструкторів масивів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (виберіть приклад Address).   

```json
{
  "FirstName": "Fred",
  "Surname": "Smith",
  "Age": 28,
  "Address": {"Street": "Hursley Park", "City": "Winchester", "Postcode": "SO21 2JN"},
  "Email": [
    {"type": "work","address": ["fred.smith@my-work.com", "fsmith@my-work.com"]},
    {"type": "home","address": ["freddy@my-social.com", "frederic.smith@very-serious.com"]}
  ],
  "Other": {"Over 18 ?": true,"Misc": null, "Alternative.Address": {"Street": "Brick Lane","City": "London", "Postcode": "E1 6RF"}}
}
```

Таблиця 8.9.

| **JSONata**                                                  | **Result**                                                   | **Коментар**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Email.address `                                             | `[   "fred.smith@my-work.com",   "fsmith@my-work.com",   "freddy@my-social.com", "frederic.smith@very-serious.com"  ]` | Чотири адреси електронної пошти повертаються в плоскому масиві |
| `Email.[address]`                                            | `[  [ "fred.smith@my-work.com", "fsmith@my-work.com" ],  [ "freddy@my-social.com", "frederic.smith@very-serious.com" ]  ]` | Кожен об'єкт  електронної пошти генерує масив адрес          |
| `[Address, Other.Alternative.Address].City` ` | `[ "Winchester", "London" ]`                                 | Вибирає значення `City`   як з об’єкту `Address`  так і з `Alternative.Address`. |                                                              |                                                              |

Подібно до того, як можна побудувати масиви, так само можуть бути побудовані на виході об'єкти JSON. У будь-якій точці шляху розташування, де очікується посилання на поле, можна використати пару фігурних дужок `{}`, що містять пари ключ/значення, розділені комами, з кожним ключем і значенням, розділеними двокрапкою: `{key1: value2, key2: value2}`. Ключі та значення можуть бути літералами або можуть бути виразами. Ключ повинен бути або рядком, або виразом, який оцінюється до рядка.               

Коли за виразом, що вибирає кілька значень, йде конструктор об'єктів, той створить єдиний об'єкт з парою ключ/значення для кожного з цих значень контексту. Якщо потрібний масив об'єктів (один для кожного значення контексту), то конструктор об'єкта повинен  слідувати за точкою `.` . У таблиці 8.10 показні приклади конструкторів об’єктів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (виберіть приклад Address).

```json
{"Phone": [
    {"type": "home", "number": "0203 544 1234"},
    {"type": "office","number": "01962 001234"},
    {"type": "office","number": "01962 001235"},
    {"type": "mobile", "number": "077 7700 1234"}]
}
```

Таблиця 8.10.

| **JSONata**                | **Result**                                                   | **Коментар**                                                 |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Phone.{type: number} `    | `[   { "home": "0203 544 1234" },    { "office": "01962 001234" },    { "office": "01962 001235" },    { "mobile": "077 7700 1234" }   ]` | Створює масив об'єктів (по одному для кожного телефону).     |
| `Phone{type: number}`  ` ` | `{   "home": "0203 544 1234",   "office": [    "01962 001234",    "01962 001235"   ],   "mobile": "077 7700 1234"  }`  ` ` | Об'єднує пари ключ/значення  в один об'єкт. Докладніше див.` [Grouping using object key expression](http://docs.jsonata.org/sorting-grouping) |
| `Phone{type: number[]} `   | `{   "home": [    "0203 544 1234"   ],   "office": [    "01962 001234",    "01962 001235"   ],   "mobile": [    "077 7700 1234"   ]  }`  ` ` | Об'єднує пари ключ/значення  в один об'єкт. У цьому випадку для узгодженості всі числа групуються в  масиви. Див. [Singleton array and value   equivalence](http://docs.jsonata.org/predicate#singleton-array-and-value-equivalence). |

### Інші можливості

JSONata дуже багата мова, опис якої не може влізти в одну лекцію. Тут оглядово наведемо деякі інші її можливості.

У JSONata все є виразами (*expression*). Вираз містить значення (*values*), функції (*functions*) та оператори (*operators*), які при оцінюванні (*evaluated*) виробляють результуюче значення. Функції та оператори застосовуються до тих значень, які в свою чергу самі можуть бути результатами оцінювання під-виразів. Таким чином, мова передбачає складені (ієрархічні) вирази. У виразах JSONata можуть бути використані коментарі з використанням синтаксису стилю мови «C».

JSONata підтримує умовні конструкції подібно до JS:

```json
predicate ? expr1 : expr2
```

Будь які назви, що починаються з знаку `$` є змінними. Змінна – це поіменоване посилання на значення. Значення може бути одним із будь-яких типів серед системних типів. Є також вбудовані в JSONata змінні:

- `$` - змінна без імені посилається на значення контексту у будь якій точці вхідної ієрархії JSON.
- `$$` - корінь входу JSON. Тільки потребується у випадках для виходу з теперішнього контексту для     тимчасового переходу вниз в інший шлях. Наприклад для перехресного посилання     або об’єднання даних.  

Окрім операторів JSONata має багато різноманітних вбудованих функцій, які як і змінні також починаються з символу `$`. Зокрема доступні функції для роботи з рядками, числами, об'єктами, масивами, датою/часом, агрегування та іншими. Можна створювати власні функції, які можуть бути збережені в змінних подібно іншим типам.  Підтримуються регулярні вирази.

Ось приклад програми на JSONata яка навіть не потребує вхідних даних. Можна спробувати його на https://try.jsonata.org/

```json
/* Довгі вирази можуть потребувати певного пояснення */
(
  $pi := 3.1415926535897932384626;
  /* JSONata не відомий своєю підтримкою графіки! */
  $plot := function($x) {(
    $floor := $string ~> $substringBefore(?, '.') ~> $number;
    $index := $floor(($x + 1) * 20 + 0.5);
    $join([0..$index].('.')) & 'O' & $join([$index..40].('.'))
  )};
  /* Факторіал — це добуток цілих чисел 1..n */
  $product := function($a, $b) { $a * $b };
  $factorial := function($n) { $n = 0 ? 1 : $reduce([1..$n], $product) };
  $sin := function($x){ /* визначає синус через косинус */
    $cos($x - $pi/2)
  };
  $cos := function($x){ /* Виводить косинус шляхом розкладання в ряд Тейлора */
    $x > $pi ? $cos($x - 2 * $pi) : $x < -$pi ? $cos($x + 2 * $pi) :
      $sum([0..12].($power(-1, $) * $power($x, 2*$) / $factorial(2*$)))
  };
  [0..24].$sin($*$pi/12).$plot($)
)
```

## Контрольні питання

1. Розкажіть про проблему сумісності при передачі даних, та як їх можна вирішити передаючи дані в текстовому форматі. Які переваги мають текстові мови та назвіть кілька відомих Вам.
2. Поясніть що таке XML. Яка принципова відмінність від HTML?
3. Назвіть основні складові XML та їх призначення.
4. Поясніть що таке XML елемент.
5. Навіщо використовуються простори імен в XML? Навіщо необхідно ідентифікувати простір імен? Як ідентифікуються простори імен?
6. Як вказується простір імен в документі XML? Навіщо потрібні префікси? Що значить відсутність префіксу в означенні простору імен?
7. Навіщо потрібні описи документів XML?
8. Розкажіть про основні принципи формування DTD.
9. Розкажіть про порядок оголошення переліку елементів, атрибутів та сутностей в DTD.
10. Розкажіть про основні принципи формування XSD.
11. Поясніть що таке цільовий простір імен XSD та як він створюється. Як він означується в схемі? Як на схему відбувається посилання в екземплярі XML?
12. Розкажіть про правила означення простого елементу в XSD. 
13. Розкажіть про правила означення атрибуту в XSD. 
14. Як накладається обмеження на тип елементів та атрибутів в XSD?
15. Розкажіть про використання обмежень та фасет в XSD.
16. Розкажіть про правила означення комплексних елементів в XSD.
17. Розкажіть про підходи до розбору та обробки XML документів через парсери.
18. Розкажіть про XPath. Наведіть приклади вибору елементів за вказаним шляхом.
19. Розкажіть про загальні принципи роботи XSLT.
20. Де і як означуються правила шаблонів XSLT?
21. Покажіть на прикладі роботу XSLT.
22. Розкажіть про призначення та синтаксис JSON.
23. Розкажіть про особливості форматування JSON в порівнянні з об'єктами JS.
24. Розкажіть про відмінності та схожості в JSON та XML.
25. Розкажіть про необхідність валідації в JSON. Розкажіть про основні принципи JSON Schema.
26. Покажіть на прикладі побудову JSON Schema.
27. Розкажіть про роботу `JSON.parse` в JS.
28. Розкажіть про роботу `JSON.stringify` в JS.
29. Яке призначення і основні ідеї JSONata? Яку аналогічну технологію можна привести для XML?
30. Як в JSONata організовано прості запити на вибірку: доступ до об'єктів, їх властивостей, масивів і їх елементів? Продемонструйте на прикладах.
31. Що таке контекст в JSONata? Як звернутися до контексту і до всього документу, незалежно від контексту?
32. Наведіть приклад предикативних запитів в JSONata.
33. Наведіть приклад виразів в JSONata з використанням різних типів операторів.
34. Наведіть приклади структурування результатів в JSONata.

## Посилання на відеозаписи лекцій

- [Л10. XML](https://youtu.be/y38GPi4BRgc?si=ry7pfS8ziY0VMwjT)
- [XML - гостьова лекція від Льва Ваняна](https://www.youtube.com/embed/ppX_0cApQZQ)
- [Запис Л11. JSON](https://youtu.be/Jz4WG5g4I4U?si=J4O9D7sA7b2iYXCP)